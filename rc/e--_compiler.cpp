/* P.S.Senior.Secondary School */

/*
 PROJECT : INTERPRTER( LANGUAGE NAME: e-- )
 NAME    : PRASHANT MAHESH
 CLASS   : 12 A
 ROLL NO : 18
 */

/*  BRIEF OVERVIEW:
 
 The main 3 components of this program are as follows:
 
 1. Tokenizer
 The Tokenizer simply divides each line into tokens of different categories. It uses the class Token to represent each token.
 2. RPN Converter
 The RPN Converter converts the tokens into the reverse polish notation. Here, errors are also identified in case an expected token is not available.
 3. RPN Evaluator
 The RPN Evaluator takes the RPN generated by the above component and evaluates it.
 
 The dynamic data structures used are:
 
 1. Stack
 Last in first out data structure.
 2. Queue
 Last in last out data structure.
 3. Vector
 Vector, is basically a resizeable array supporting additional "stacklike" functions like push_back.
 */

typedef int Token_type;
typedef int Data_type;
typedef int sub_type;

#define UNKNOWN 0
#define LITERAL 1
#define IDENTIFIER 2
#define OPERATOR 3
#define KEYWORD 4
#define PUNCTUATOR 5
#define INTEGER 6
#define NUMERIC 7
#define STRING 8
#define CHAR  9
#define VARIABLE 10
#define FUNCTION 11
#define HASHED 12
#define IOFUNCTION 13
#define DATATYPE 14
#define BOOLEAN 15
#define PRE 16
#define POST 17
#define ARRAYELEM 18
#define STRINGCHAR 19
#define UNDEFINED 20
#define TIME 21
#define DATE 22


#include <iostream>
#include <cctype>
#include <cstring>
#include <fstream>
#include <cstdlib>
#include <iomanip>
using namespace std;

int interpretationSuccessful = 1;

/********** DATA STRUCTURES: BEGIN **********/

/********** INTERFACES **********/

//CLASS: Stack (interface)
template <typename elemType>
class Stack {
public:
    struct Node {
        elemType data;
        Node *next;
        Node() {
            next = 0;
        }
    };
    Node *top;
    Stack();
    Stack(const Stack<elemType> &s);
    Stack<elemType> operator=(const Stack<elemType> &s);
    void flush();
    ~Stack();
    void push(elemType d);
    int pop(elemType &d);
    int pop();
    elemType& Top();
    int isEmpty();
};

//CLASS: Queue (interface)
template <typename elemType>
class Queue {
public:
    struct Node {
        elemType data;
        Node *next;
        Node() {
            next = 0;
        }
    };
    Node *front;
    Node *rear;
    Queue();
    Queue(const Queue<elemType> &q);
    void flush();
    ~Queue();
    void qinsert(elemType d);
    int qdelete(elemType &d);
    Queue<elemType> operator=(const Queue<elemType> &q);
    elemType& Front();
    int isEmpty();
    
};

//CLASS: Vector (interface)
template <typename elemType>
class Vector {
    elemType *data;
    unsigned long _size;
public:
    Vector();
    Vector(const Vector<elemType> &v);
    Vector<elemType> operator=(const Vector<elemType> &v);
    void flush();
    ~ Vector();
    Vector(unsigned long s);
    Vector(unsigned long s,const elemType e);
    int push_back(const elemType e);
    elemType& operator[](unsigned long i);
    unsigned long size() const;
};


/**********IMPLEMENTATION**********/

/* CLASS: Stack - Implementation */

template <typename elemType>
Stack<elemType>::Stack() {
    top = 0;
}

template <typename elemType>
Stack<elemType>::Stack(const Stack<elemType> &s) {
    if(s.top) {
        top = new Node;
        if(top) {
            top->data = s.top->data;
            top->next = 0;
            Node *curr2 = s.top->next,*curr1 = top;
            while(curr2 && curr1) {
                curr1->next = new Node;
                if(curr1->next) {
                    curr1 = curr1->next;
                    curr1->data = curr2->data;
                    curr1->next = 0;
                    curr2 = curr2->next;
                }
                else {
                    curr1 = 0;
                }
            }
        }
    }
    else top = 0;
}

template <typename elemType>
void Stack<elemType>::flush() {
    elemType t;
    while(pop(t));
}

template <typename elemType>
Stack<elemType>::~Stack() {
    flush();
}

template <typename elemType>
void Stack<elemType>::push(elemType d) {
    Node *tmp = new Node;
    if(tmp) {
        tmp->data = d;
        tmp->next = top;
        top = tmp;
    }
    else {
        cout<<"ERROR: Heap exhausted. Cannot push value into stack."<<endl;
    }
}

template <typename elemType>
int Stack<elemType>::pop(elemType &d) {
    if(top) {
        d = top->data;
        Node *tmp = top;
        top = top->next;
        delete tmp;
        return 1;
    }
    else {
        return 0;
    }
}

template <typename elemType>
int Stack<elemType>::pop() {
    if(top) {
        Node *tmp = top;
        top = top->next;
        delete tmp;
        return 1;
    }
    else {
        return 0;
    }
}

template <typename elemType>
elemType& Stack<elemType>::Top() {
    if(top) {
        return top->data;
    }
    else {
        elemType *p = new elemType;
        return *p;
    }
}

template <typename elemType>
Stack<elemType> Stack<elemType>::operator=(const Stack<elemType> &s) {
    flush();
    if(s.top) {
        top = new Node;
        if(top) {
            top->data = s.top->data;
            top->next;
            Node *curr2 = s.top->next,curr1 = top;
            while(curr2 && curr1) {
                curr1->next = new Node;
                if(curr1->next) {
                    curr1 = curr1->next;
                    curr1->data = curr2->data;
                    curr1->next = 0;
                    curr2 = curr2->next;
                }
                else {
                    curr1 = 0;
                }
            }
        }
    }
    return s;
}

template <typename elemType>
int Stack<elemType>::isEmpty() {
    return top == 0;
}

/* CLASS: Queue - Implementation */

template <typename elemType>
Queue<elemType>::Queue() {
    front = rear = 0;
}

template <typename elemType>
Queue<elemType>::Queue(const Queue<elemType> &q) {
    if(q.front) {
        Node *tmp = new Node;
        if(tmp) {
            tmp->data = q.front->data;
            tmp->next = 0;
            front = tmp;
            Node *curr1 = front,*curr2 = q.front->next;
            while(curr2) {
                curr1->next = new Node;
                if(curr1->next) {
                    curr1 = curr1->next;
                    curr1->data = curr2->data;
                    curr1->next = 0;
                    curr2 = curr2->next;
                }
            }
            rear = curr1;
            
        }
    }
    else front = rear = 0;
}

template <typename elemType>
void Queue<elemType>::flush() {
    elemType t;
    while(qdelete(t));
}

template <typename elemType>
Queue<elemType>::~Queue() {
    flush();
}

template <typename elemType>
void Queue<elemType>::qinsert(elemType d) {
    Node *tmp = new Node;
    if(tmp) {
        tmp->data = d;
        if(front == 0)
            front = rear = tmp;
        else {
            rear->next = tmp;
            rear = tmp;
        }
    }
    else {
        cout<<"ERROR: Heap Exhausted. Cannot insert into queue."<<endl;
    }
    
}

template <typename elemType>
int Queue<elemType>::qdelete(elemType &d) {
    if(front) {
        d = front->data;
        Node *tmp = front;
        front = front->next;
        delete tmp;
        if(front == 0) rear = 0;
        return 1;
    }
    else {
        return 0;
    }
    
}

template <typename elemType>
Queue<elemType> Queue<elemType>::operator=(const Queue<elemType> &q) {
    flush();
    if(q.front) {
        Node *tmp = new Node;
        if(tmp) {
            tmp->data = q.front->data;
            tmp->next = 0;
            front = tmp;
            Node *curr1 = front,*curr2 = q.front->next;
            while(curr2) {
                curr1->next = new Node;
                if(curr1->next) {
                    curr1 = curr1->next;
                    curr1->data = curr2->data;
                    curr1->next = 0;
                    curr2 = curr2->next;
                }
            }
            rear = curr1;
            
        }
    }
    else front = rear = 0;
    return q;
}

template <typename elemType>
elemType& Queue<elemType>::Front() {
    if(front) return front->data;
    else {
        elemType *p = new elemType;
        return *p;
    }
}

template <typename elemType>
int Queue<elemType>::isEmpty() {
    return front == 0;
}

/*** Vector : Implementation ***/

template <typename elemType>
Vector<elemType>::Vector() {
    _size = 0;
    data = 0;
}

template<typename elemType>
void Vector<elemType>::flush() {
    if(_size > 0) delete[] data;
    _size = 0;
}

template<typename elemType>
Vector<elemType>::~Vector() {
    flush();
}

template<typename elemType>
Vector<elemType>::Vector(unsigned long s) {
    _size = s;
    data = new elemType[s];
}

template<typename elemType>
Vector<elemType>::Vector(unsigned long s,const elemType e) {
    _size = s;
    data = new elemType[s];
    if(data) {
        for(int i = 0;i < _size;i++) data[i] = e;
    }
}

template<typename elemType>
Vector<elemType>::Vector(const Vector<elemType> &v) {
    _size = v._size;
    data = new elemType[v._size];
    if(data) {
        for(int i = 0;i < _size;i++) data[i] = v.data[i];
    }
}

template <typename elemType>
Vector<elemType> Vector<elemType>::operator=(const Vector<elemType> &v) {
    _size = v._size;
    data = new elemType[v._size];
    if(data) {
        for(int i = 0;i < _size;i++) data[i] = v.data[i];
    }
    return v;
}

template<typename elemType>
int Vector<elemType>::push_back(const elemType e) {
    elemType* temp = new elemType[_size];
    if(temp) {
        for(int i = 0;i < _size;i++) temp[i] = data[i];
        data = new elemType[_size + 1];
        if(data) {
            for(int i = 0;i < _size;i++) data[i] = temp[i];
            data[_size] = e;
            _size++;
            return 1;
        }
    }
    return 0;
}

template<typename elemType>
elemType& Vector<elemType>::operator[](unsigned long i) {
    elemType *t = new elemType;
    if(i >= _size) {cout<<i<<' '<<"ERROR: OUT OF BOUNDS"<<endl;}
    else {
        delete t;
        return data[i];
    }
    return *t;
}

template<typename elemType>
unsigned long  Vector<elemType>::size() const {
    return _size;
}

/***** DATA STRUCTURES: END *****/

/* CLASS       : Token
 DESCRIPTION : Stores information about a token, the value,type,subtype.
 */

int currentLine = 1;

class Token {
    char val[101];
    Token_type t;
    sub_type t2;
    int lineNumber;
public:
    Token();
    Token(char s[],Token_type t,sub_type t2);
    Token(const Token &tok);
    void setType(Token_type t);
    void setSubType(sub_type t2);
    Token_type type();
    sub_type subType();
    char* value();
    int getLineNumber();
    const Token& operator=(const Token &tok);
};

/* CLASS: Token (IMPLEMENTATION) */

Token::Token() {
    val[0] = 0;
    t = UNKNOWN;
    t2 = UNKNOWN;
    lineNumber = currentLine;
}

Token::Token(char s[],Token_type t = UNKNOWN,sub_type t2 = UNKNOWN) {
    strcpy(val, s);
    this->t = t;
    this->t2 = t2;
    lineNumber = currentLine;
}

Token::Token(const Token &tok) {
    strcpy(val,tok.val);
    t = tok.t;
    t2 = tok.t2;
    lineNumber = tok.lineNumber;
}

void Token::setType(Token_type t) {
    this->t = t;
}
void Token::setSubType(sub_type t2) {
    this->t2 = t2;
}

Token_type Token::type() {
    return t;
}
sub_type Token::subType() {
    return t2;
}

char* Token::value() {
    return val;
}

const Token& Token::operator=(const Token &tok) {
    strcpy(val,tok.val);
    t = tok.t;
    t2 = tok.t2;
    lineNumber = tok.lineNumber;
    return tok;
}

int Token::getLineNumber() {
    return lineNumber;
}

/* END OF IMPLEMENTATION: CLASS - Token */



/*****
 CLASS      : ERROR
 DESCRIPTION: This class is used to keep track of a interpretation error, 2 data members: line number and the flag.
 ****/
class Error {
    int lineNumber;
    char flag[101];
public:
    Error();
    Error(char fg[],int ln);
    int getLineNumber();
    char* getFlag();
};

Error::Error() {
    lineNumber = -1;
    flag[0] = 0;
}

Error::Error(char fg[],int ln) {
    strcpy(flag,fg);
    lineNumber = ln;
}

int Error::getLineNumber() {
    return lineNumber;
}

char* Error::getFlag() {
    return flag;
}

//All errors are stored in this variable.
Vector<Error> errors;

typedef Queue<Token> RPN;

// returns an integer extracted from the given string of the format "#(int)"
int getIndexOfHash(char n[]) {
    int a = 0;
    for(int i = 1; n[i];i++) {
        a = a * 10 + n[i] - '0';
    }
    return a;
}

//converts the string given,to a character. (format: "'(char)'")
char convertToCharacter(char s[]) {
    return s[1];
}

//converts the string given,to an ordniary string,removing the double quotes. (format: ""(string)"")
void convertToString(char s[],char d[]) {
    d[0] = 0;
    for(int i = 1; s[i] != '"';i++) {
        d[i - 1] = s[i];
        d[i] = 0;
    }
}

//converts the integer parameter to a token, by converting to a string first.
Token convertIntegerToToken(int a) {
    char str[101];
    sprintf(str,"%d",a);
    return Token(str,LITERAL,INTEGER);
}

//converts the double parameter to a token, by converting to a string first.
Token convertNumericToToken(double a) {
    char n[101];
    sprintf(n,"%f",a);
    return Token(n,LITERAL,NUMERIC);
}

/****
 CLASS: Time
 DESCRIPTION: This struct stores info about a particular time. Supports operations like addition,subtraction and comparisions.
****/

//Interface
struct Time {
    int hour,minute,second;
    Time(int h = 0,int m = 0, int s = 0);
    int operator==(Time &t);
    int operator!=(Time &t);
    int operator>(Time &t);
    int operator<=(Time &t);
    int operator<(Time &t);
    int operator>=(Time &t);
    Time operator+(Time &t);
    Time operator-(Time &t);
    void display();
    int checkFormat(char *n);
    void assign(char *n);
};


/* Time : Implementation */
 */
Time::Time(int h,int m, int s) {
    hour = h;
    minute = m;
    second = s;
}

int Time::operator==(Time &t) {
    return hour == t.hour && minute == t.minute && second == t.second;
}

int Time::operator!=(Time &t) {
    return !(*this == t);
}

int Time::operator>(Time &t) {
    if(hour > t.hour) return 1;
    else if(hour == t.hour) {
        if(minute > t.minute) return 1;
        else if(minute == t.minute) {
            return second > t.second;
        }
        else {
            return 0;
        }
    }
    else {
        return 0;
    }
}
int Time::operator<=(Time &t) {
    return !(*this > t);
}
int Time::operator<(Time &t) {
    return *this <= t && *this != t;
}
int Time::operator>=(Time &t) {
    return *this > t || *this == t;
}

Time Time::operator+(Time &t) {
    Time temp;
    int seconds = (hour + t.hour) * 3600 + (minute + t.minute) * 60 + second + t.second;
    seconds%= 3600 * 24;
    temp.hour = seconds / 3600;
    temp.minute = (seconds % 3600) / 60;
    temp.second = (seconds % 60);
    return temp;
}
Time Time::operator-(Time &t) {
    Time temp;
    int seconds = (hour - t.hour) * 3600 + (minute - t.minute) * 60 + second - t.second;
    seconds += 3600 * 24;
    seconds%= 3600 * 24;
    temp.hour = seconds / 3600;
    temp.minute = (seconds % 3600) / 60;
    temp.second = (seconds % 60);
    return temp;
    
}

void Time::display() {
    printf("%02d:%02d:%02d",hour,minute,second);
}

//checks whether the string passed as parameter is in the required "time" format ( "HH:MM::SS" ).
int Time::checkFormat(char *n) {
    if(strlen(n) == 8 && isdigit(n[0]) && isdigit(n[1]) && isdigit(n[3]) && isdigit(n[4]) && isdigit(n[6]) && isdigit(n[7]) && n[2] == ':' && n[5] == ':') {
        return 1;
    }
    else {
        return 0;
    }
}

void Time::assign(char *n) {
    hour = (n[0] - '0') * 10;
    hour+=(n[1] - '0');
    minute = (n[3] - '0') * 10;
    minute+= (n[4] - '0');
    second = (n[6] - '0') * 10;
    second+= (n[7] - '0');
}

//Stores all the time values declared.
Vector<Time> times;

//creates a string of the format "#(int)". Assigns the string to the argument.
void hashify(int n,char a[]) {
    Stack<int> s;
    while(n != 0) {
        s.push(n % 10);
        n/=10;
    }
    int x;
    int i = 1;
    a[0] = '#';
    while(s.pop(x)) {
        a[i++] = '0' + x;
    }
    if(i == 1) a[i++] ='0';
    a[i] = 0;
}


#define JAN 0
#define FEB 1
#define MAR 2
#define APR 3
#define MAY 4
#define JUN 5
#define JUL 6
#define AUG 7
#define SEP 8
#define OCT 9
#define NOV 10
#define DEC 11
struct Date {
    int day,month,year;
public:
    Date(int d = -1,int m = -1,int y = 0) {
        day = d;
        month = m;
        year = y;
    }
    void operator++() {
        if(day == 30) {
            switch(month) {
                case APR:
                case JUN:
                case SEP:
                case NOV: {
                    day = 1;
                    month++;
                    break;
                }
                default: {
                    day++;
                    break;
                }
            }
        }
        else if(day == 31) {
            switch(month) {
                case JAN:
                case MAR:
                case MAY:
                case JUL:
                case AUG:
                case OCT: {
                    day = 1;
                    month++;
                    break;
                }
                case DEC: {
                    day = 1;
                    month = JAN;
                    year++;
                    break;
                }
                default: {
                    day++;
                    break;
                }
            }
        }
        else if(day == 29 && month == FEB ) {
            day = 1;
            month = MAR;
        }
        else if(day == 28 && month == FEB) {
            if( ( (year % 4 == 0 && year % 100 != 0) || year % 400 == 0 ) ) day++;
            else {
                day = 1;
                month = MAR;
            }
        }
        else {
            day++;
        }
    }
    int operator==(Date &d) {
        return day == d.day && month == d.month && year == d.year;
    }
    int operator!=(Date &d) {
        return ! (*this == d);
    }
    int operator>(Date &d) {
        if(year == d.year) {
            if(month == d.month) {
                return day > d.day;
            }
            else if(month > d.month) return 1;
        }
        else if(year > d.year) return 1;
        return 0;
    }
    int operator<=(Date &d) {
        return !(*this > d);
    }
    int operator<(Date &d) {
        return *this <= d && *this != d;
    }
    int operator>=(Date &d) {
        return *this > d || *this == d;
    }
    Date operator+(int d) {
        Date t = *this;
        while(d--) ++(t);
        return t;
    }
    void display() {
        printf("%02d-%02d-%04d",day,month + 1,year);
    }
    int checkFormat(char *n) {
        if(strlen(n) == 10) {
            int a[] = {0,1,3,4,6,7,8,9};
            for(int i= 0;i < 8;i++) if(!isdigit(n[a[i]])) return 0;
            if(n[2] != '-' && n[5] != '-') return 0;
        }
        else {
            return 0;
        }
        return 1;
    }
    void assign(char*n) {
        day = (n[0] - '0') * 10;
        day+= (n[1] - '0');
        month = (n[3] - '0') * 10;
        month+= (n[4] - '0') - 1;
        year = (n[6] - '0') * 1000;
        year+= (n[7] - '0') * 100;
        year+= (n[8] - '0') * 10;
        year+= (n[9] - '0');
    }
};



Vector<Date> dates;

/* CLASS        : Variable
 DESCRIPTION   : Stores information about a variable, the identifier, the value (as a token),data type.
 (Interface)
 */
class Variable {
    char identifier[21];
    Data_type _d;
    Token _value;
    int _isArray;
    Vector<Token> _values;
public:
    Variable();
    Variable(char n[],Data_type d,int isArray,int size);
    Variable(const Variable &v);
    void operator=(const Variable &v);
    void setValue(Token v);
    void setValue(Token v,unsigned int i);
    Token value();
    Token value(unsigned int i);
    char* value_string();
    char* getID();
    Data_type getDataType();
    int isArray();
};

/** IMPLEMENTATION: CLASS - VARIABLE **/

Variable::Variable() {
    identifier[0] = 0;
    _d = UNKNOWN;
    _isArray = 0;
}

Variable::Variable(char n[],Data_type d = UNKNOWN,int isArray = 0,int size = 0) {
    strcpy(identifier,n);
    this->_d = d;
    _isArray = isArray;
    if(_isArray) {
        _values = Vector<Token>(size);
    }
}

Variable::Variable(const Variable &v) {
    strcpy(identifier, v.identifier);
    _d = v._d;
    _value = v._value;
    _isArray = v._isArray;
    if(_isArray) {
        _values = Vector<Token>(v._values.size());
    }
}

void Variable::operator=(const Variable &v) {
    strcpy(identifier, v.identifier);
    _d = v._d;
    _value = v._value;
    _isArray = v._isArray;
    if(_isArray) {
        _values = Vector<Token>(v._values.size());
    }
}

void Variable::setValue(Token v) {
    if(_d == INTEGER) {
        if(v.subType() ==INTEGER || v.subType() == NUMERIC) {
            _value = convertIntegerToToken(atoi(v.value()));
        }
        else {
            errors.push_back(Error("Error: Invalid Assignment",v.getLineNumber())  );
            interpretationSuccessful = 0;
        }
    }
    else if(_d == NUMERIC) {
        if(v.subType() == INTEGER || v.subType() == NUMERIC) {
            _value = convertNumericToToken(atof(v.value()));
        }
        else {
            errors.push_back(Error("Error: Invalid Assignment",v.getLineNumber())  );
            interpretationSuccessful = 0;
        }
    }
    else if(_d == TIME) {
        if(v.subType() == TIME || v.subType() == STRING) {
            if(v.subType() == TIME) {
                _value = v;
            }
            else if(v.subType() == STRING) {
                Time t;
                char n[101];
                convertToString(v.value(), n);
                if(t.checkFormat(n)) {
                    t.assign(n);
                    times.push_back(t);
                    hashify((int)times.size() - 1,n);
                    _value = Token(n,LITERAL,TIME);
                }
                else {
                    errors.push_back(Error("Error: Invalid Time Format",v.getLineNumber()));
                    interpretationSuccessful = 0;
                }
            }
        }
        else {
            errors.push_back(Error("Error: Invalid Time assignment.",v.getLineNumber()));
            interpretationSuccessful = 0;
        }
    }
    else if(_d == DATE ) {
        if(v.subType() == DATE) {
            _value = v;
        }
        else if(v.subType() == STRING) {
            Date d;
            char n[101];
            convertToString(v.value(), n);
            if(d.checkFormat(n)) {
                d.assign(n);
                dates.push_back(d);
                hashify((int)dates.size() - 1,n);
                _value = Token(n,LITERAL,DATE);
            }
            else {
                errors.push_back(Error("Error: Invalid Date Format",v.getLineNumber()));
                interpretationSuccessful = 0;
            }
        }
        else {
            errors.push_back(Error("Error: Invalid Date assignment.",v.getLineNumber()));
            interpretationSuccessful = 0;
        }
    }
    else {
        if(_d == v.subType()) {
            _value = v;
        }
        else {
            errors.push_back(Error("Error: Invalid Assignment",v.getLineNumber())  );
            interpretationSuccessful = 0;
        }
    }
}

void Variable::setValue(Token v,unsigned int i) {
    if(i < _values.size()) {
        if(_d == INTEGER) {
            if(v.subType() ==INTEGER || v.subType() == NUMERIC) {
                _values[i] = convertIntegerToToken(atoi(v.value()));
            }
            else {
                errors.push_back(Error("Error: Invalid Assignment",v.getLineNumber())  );
            }
        }
        else if(_d == NUMERIC) {
            if(v.subType() == INTEGER || v.subType() == NUMERIC) {
                _values[i] = convertNumericToToken(atof(v.value()));
            }
            else {
                errors.push_back(Error("Error: Invalid Assignment",v.getLineNumber())  );
            }
        }
        else {
            if(_d == v.subType()) {
                _values[i] = v;
            }
            else {
                errors.push_back(Error("Error: Invalid Assignment",v.getLineNumber())  );
            }
        }
    }
    else {
        errors.push_back(Error("Error: Invalid element access",-1) );
    }
}

Token Variable::value() {
    return _value;
}

char* Variable::value_string() {
    return _value.value();
}

char* Variable::getID() {
    return identifier;
}

Data_type Variable::getDataType() {
    return _d;
}

Token Variable::value(unsigned int i) {
    if(_isArray) {
        if(_values.size() > i) return _values[i];
    }
    return Token();
}

int Variable::isArray() {
    return _isArray;
}

/** END OF IMPLEMENTATION: CLASS - VARIABLE */


Token nullToken;

//All variables are stored in this variable.
Stack< Vector<Variable> > variables;

//FORWARD DECLARATION OF converToRPN(),explained later.
RPN convertToRPN(Queue<Token> tokens,Vector<Variable> &v);

//FORWARD DECLARATION OF evaluateRPN(),explained later.
Token evaluateRPN(RPN r);

//FORWARD DECLARATION OF checkRPN(),explained later.
void checkRPN(RPN r);





Variable& getVariable(char s[]) {
    Stack<Vector<Variable> >::Node *current = variables.top;
    while(current) {
        for(int i = 0;i < current->data.size();i++) {
            if(strcmp(current->data[i].getID(),s) == 0) return current-> data[i];
        }
        current = current->next;
    }
    Variable *v = new Variable;
    return *v;
}

int isVariable(char s[]) {
    Stack<Vector<Variable> >::Node *current = variables.top;
    while(current) {
        for(int i = 0;i < current->data.size();i++) {
            if(strcmp(current->data[i].getID(),s) == 0) return 1;
        }
        current = current->next;
    }
    return 0;
}

//Used to store information about an array element, the identifier and index.
struct arrayElem {
    char v[101];
    int i;
};

struct stringChar {
    char v[101];
    int i;
};

//Stores all required array elements.
Vector<arrayElem> arrayElems;

//Stores all required string-character elements.
Vector<stringChar> stringChars;


/* CLASS       : FUNCTION
 DESCRIPTION : Stores information and performs operations relating to a function.
 */
class Function {
    char _id[101];
    Vector<Variable> parameters,inFunctionVariables;
    RPN statements;
    int _hasReturned;
    Token toReturn;
public:
    Function();
    Function(char id[],Queue<Token> parameters,Queue<Token> statements);
    char* getID();
    Token execute(Queue<Token> p);
    void setReturn(Token t);
    int hasReturned();
    void checkFunction(Queue<Token> p);
};

// Function stack, in case of multiple functions being called.
Stack<Function> functionStack;

/*
 ClASS           : Function
 MEMBER_FUNCTION : (Constructor)
 DESCRIPTION     : initializes data members.
 RETURN_TYPE     : (none)
 PARAMETERS      : (none)
 */
Function::Function() {
    _id[0] = 0;
    _hasReturned = 0;
    
}

/*
 ClASS           : Function
 MEMBER_FUNCTION : (Constructor)
 DESCRIPTION     : initializes data members to given parameters.
 RETURN_TYPE     : (none)
 PARAMETERS      : (none)
 */
Function::Function(char id[],Queue<Token> parameters,Queue<Token> statements) {
    _hasReturned = 0;
    strcpy(_id,id);
    Token t;
    while(parameters.qdelete(t)) {
        int type_id;
        if(strcmp(t.value(),"Integer")  == 0) {
            type_id = INTEGER;
        }
        else if(strcmp(t.value(),"Numeric") == 0) {
            type_id = NUMERIC;
        }
        else if(strcmp(t.value(),"String") == 0) {
            type_id = STRING;
        }
        else if(strcmp(t.value(),"Char") == 0) {
            type_id = CHAR;
        }
        else if(strcmp(t.value(),"Boolean") == 0) {
            type_id = BOOLEAN;
        }
        else {
            cout<<"ERROR: CONVERSION1"<<endl;
            interpretationSuccessful = 0;
        }
        if(!parameters.qdelete(t)) {
            cout<<"ERROR CONVERSION"<<endl;
            interpretationSuccessful = 0;
        }
        else {
            if(t.type() == UNKNOWN) {
                this->parameters.push_back(Variable(t.value(),type_id));
            }
        }
        if(parameters.qdelete(t) ) {
            if(t.value()[0] != ',') {
                cout<<"ERROR FUNCTION DECLARATION"<<endl;
                interpretationSuccessful = 0;
            }
        }
    }
    variables.push(this->parameters);
    this->statements = convertToRPN(statements,this->inFunctionVariables);
    variables.pop();
}

/*
 ClASS           : Function
 MEMBER_FUNCTION : execute()
 DESCRIPTION     : executes the given function, assigning the parameter(s), adding the required variables to the stack.
 RETURN_TYPE     : Token
 PARAMETERS      : Queue<Token> p
 */
Token Function::execute(Queue<Token> p) {
    Token r;
    Vector<Token> params;
    Token t;
    Queue<Token> temp;
    while(p.qdelete(t)) {
        if(t.value()[0] == ',') {
            if(temp.isEmpty()) {
                errors.push_back(Error("No Parameter",t.getLineNumber())  );
                interpretationSuccessful = 0;
            }
            else {
                Token r = evaluateRPN(temp);
                params.push_back(r);
            }
        }
        else {
            temp.qinsert(t);
        }
    }
    if(!temp.isEmpty()) {
        Token r = evaluateRPN(temp);
        params.push_back(r);
    }
    if(params.size() < parameters.size()) {
        errors.push_back(Error("Insufficient Parameters",t.getLineNumber())  );
        interpretationSuccessful = 0;
    }
    else if( params.size() > parameters.size()) {
        errors.push_back(Error("Excess Parameters",t.getLineNumber())  );
        interpretationSuccessful = 0;
    }
    else {
        for(int i = 0;i < parameters.size();i++) {
            parameters[i].setValue(params[i]);
        }
        variables.push(parameters);
        variables.push(inFunctionVariables);
        functionStack.push(*this);
        evaluateRPN(statements);
        variables.pop();
        variables.pop();
    }
    r =functionStack.Top().toReturn;
    functionStack.pop();
    return r;
}

/*
 ClASS           : Function
 MEMBER_FUNCTION : getID()
 DESCRIPTION     : An accessor function for the function ID.
 RETURN_TYPE     : char*
 PARAMETERS      : (none)
 */
char* Function::getID() {
    return _id;
}

/*
 ClASS           : Function
 MEMBER_FUNCTION : setReturn()
 DESCRIPTION     : sets the token to be returned by the function.
 RETURN_TYPE     : void
 PARAMETERS      : Token
 */
void Function::setReturn(Token t) {
    _hasReturned = 1;
    toReturn = t;
    
}

/*
 ClASS           : Function
 MEMBER_FUNCTION : hasReturned()
 DESCRIPTION     : returns a boolean value stating whether the function has a return token assigned.
 RETURN_TYPE     : int
 PARAMETERS      : (none)
 */
int Function::hasReturned() {
    return _hasReturned;
}

void Function::checkFunction(Queue<Token> p) {
    Token t;
    int np = 0;
    Queue<Token> temp;
    while(p.qdelete(t)) {
        if(t.value()[0] == ',') {
            if(temp.isEmpty()) {
                errors.push_back(Error("No Parameter",t.getLineNumber())  );
                interpretationSuccessful = 0;
            }
            else {
                checkRPN(temp);
                temp.flush();
                np++;
            }
        }
        else {
            temp.qinsert(t);
        }
    }
    if(!temp.isEmpty()) {
        checkRPN(temp);
        np++;
    }
    if(np > parameters.size()) {
        errors.push_back(Error("Excess Parameter(s)",t.getLineNumber())  );
        interpretationSuccessful = 0;
    }
    else if(np < parameters.size()) {
        errors.push_back(Error("Insufficient Parameter(s)",t.getLineNumber())  );
        interpretationSuccessful = 0;
    }
}

//Stores information relating to an if or while statement. (condition,statements)
struct cs_if {
    RPN If_statement,If_condition,Else_statement;
    Vector<Variable> If_variables,Else_variables;
};

//Stores information relating to a for statement. (3 parameters, statements)
struct cs_for {
    RPN s1,s2,s3,statements;
    Vector<Variable> For_variables,Counter_variables;
    
};

Vector<RPN> rpns;
Vector<cs_if> ifs;
Vector<cs_for> fors;
Vector<Function> functions;

/**********
 COMPONENT_1: TOKENIZER
 DESCRIPTON:
 This section of code takes a string containning the program(a line of code at a time) and converts it into a queue of tokens.
 Each token is organised using the above declared class Token. The token type, subtypes(if any) are also found here.
 
 
 
 **********/

/* Arrays of strings, which store all posibile tokens in the input, excluding literals and identifiers. */
char keywords[19][15] = {"if","else","while","for","do","true","false","not","in","write","writeLine","readInteger","readLine","readNumeric","read","function","length","readTime","readDate"};
char punctuators[11][2] = {"[","]","(",")","{","}",",",":",";"};
char operators[24][10] = {"+","-","*","/","=",".","%","+=","-=","*=","/=","%=","++","--",">","<",">=","<=","==","=","!=","and","or","return"};
char ioFunctions[8][15] = {"write","writeLine","readInteger","readLine","readNumeric","read","readTime","readDate"};
char dataTypes[7][10] = {"Integer","Numeric","String","Char","Boolean","Time","Date"};


/*
 FUNCTION    : getType();
 DESCRIPTION : returns the identified type of the given string. returns UNKNOWN if no valid match occured.
 RETURNS     : Token_type
 PARAMETERS  : const char*
 */
Token_type getType(const char *s) {
    for(int i = 0;i < 19;i++) if(strcmp(s, keywords[i]) == 0) return KEYWORD;
    for(int i = 0;i < 11;i++) if(strcmp(s, punctuators[i]) == 0) return PUNCTUATOR;
    for(int i = 0;i < 24;i++) if(strcmp(s,operators[i]) == 0) return OPERATOR;
    if(isdigit(s[0]) || s[0] == '\'' || s[0] == '"') return LITERAL;
    for(int i = 0;i < 7;i++) if(strcmp(s,dataTypes[i]) == 0) return DATATYPE;
    Stack<Vector<Variable> > st = variables;
    Vector<Variable> t;
    while(st.pop(t)) {
        for(int i = 0;i < t.size();i++) {if(strcmp(t[i].getID(),s) == 0) return VARIABLE;}
    }
    return UNKNOWN;
}

/*
 FUNCTION    : isIOFunction();
 DESCRIPTION : returns whether the given string is an input/ouput function identifier.
 RETURNS     : int
 PARAMETERS  : char[]
 */
int isIOFunction(char n[]) {
    for(int i = 0;i < 8;i++) if(strcmp(n, ioFunctions[i]) == 0) return 1;
    return 0;
}

/*
 FUNCTION    : tokenize();
 DESCRIPTION : Takes a string and tokenizes it into elements, identifying their type, and generating a queue of tokens.
 The tracking method is used to tokeinze the string. For example, when literal tracking is in progress,
 it keeps reading till it reaches an unexpected character(or expected character to end).
 RETURNS     : Queue<Token>
 PARAMETERS  : char[]
 */
Queue<Token> tokenize(char line[]) {
    Queue<Token> tokens;
    int word_tracking = 0;
    int literal_tracking = 0;
    int track_type = UNKNOWN;
    char tok[51];
    int tokpos = 0;
    tok[0] = 0;
    for(int i = 0; line[i];i++) {
        if(word_tracking) {
            if(isalnum(line[i]) || line[i] == '_') {
                tok[tokpos++] = line[i];
                tok[tokpos] = 0;
            }
            else {
                i--;
                int type = getType(tok);
                if(type == VARIABLE || type == FUNCTION) {
                    Token t(tok,IDENTIFIER,VARIABLE);
                    tokens.qinsert( t );
                }
                else if(type == KEYWORD) {
                    if(isIOFunction(tok)) tokens.qinsert(Token(tok,KEYWORD,IOFUNCTION));
                    else tokens.qinsert(Token(tok,KEYWORD));
                }
                else if(type == OPERATOR) {
                    tokens.qinsert(Token(tok,OPERATOR));
                }
                else {
                    tokens.qinsert(Token(tok,type));
                }
                tok[0] = 0;
                tokpos = 0;
                word_tracking = 0;
            }
        }
        else if(!literal_tracking && isalpha(line[i])) {
            word_tracking = 1;
            tok[0] = line[i];
            tok[1] = 0;
            tokpos = 1;
        }
        else if(literal_tracking) {
            if(track_type == INTEGER) {
                if(isdigit(line[i])) {
                    tok[tokpos++] = line[i];
                    tok[tokpos] = 0;
                }
                else if(line[i] == '.') {
                    if(!isdigit(line[i + 1])) {
                        errors.push_back(Error("Incomplete numeric",currentLine));
                        interpretationSuccessful = 0;
                    }
                    tok[tokpos++] = '.';
                    tok[tokpos] = 0;
                    track_type = NUMERIC;
                }
                else {
                    i--;
                    tokens.qinsert(Token(tok,LITERAL,track_type));
                    tok[0] = 0;
                    tokpos = 0;
                    literal_tracking = 0;
                    track_type = UNKNOWN;
                }
            }
            else if(track_type == NUMERIC) {
                if(isdigit(line[i])) {
                    tok[tokpos++] = line[i];
                    tok[tokpos] = 0;
                }
                else {
                    i--;
                    tokens.qinsert(Token(tok,LITERAL,track_type));
                    tok[0] = 0;
                    tokpos = 0;
                    literal_tracking = 0;
                    track_type = UNKNOWN;
                }
            }
            else if(track_type == STRING) {
                if(line[i] == '"') {
                    tok[tokpos++] = '"';
                    tok[tokpos] = 0;
                    tokens.qinsert(Token(tok,LITERAL,track_type));
                    tok[0] = 0;
                    tokpos = 0;
                    literal_tracking = 0;
                    track_type = UNKNOWN;
                }
                else {
                    tok[tokpos++] = line[i];
                    tok[tokpos] = 0;
                }
            }
        }
        else if( (line[i] == '-' && isdigit(line[i + 1])) || isdigit(line[i])) {
            literal_tracking = 1;
            track_type = INTEGER;
            tok[0] = line[i];
            tok[1] = 0;
            tokpos  = 1;
        }
        else if(line[i] == '\'') {
            if(line[i + 2] != '\'') {
                errors.push_back(Error("Invalid character",currentLine));
                interpretationSuccessful = 0;
            }
            else {
                tok[0] = tok[2] = '\'';
                tok[1] = line[i + 1];
                tok[3] = 0;
                tokens.qinsert(Token(tok,LITERAL,CHAR));
                tok[0] = 0;
                tokpos = 0;
                i+=2;
            }
        }
        else if(line[i] == '\"') {
            tok[0] = '"';
            literal_tracking = 1;
            track_type = STRING;
            tok[1] = 0;
            tokpos = 1;
        }
        else if(line[i] == '.' && isdigit(line[i + 1])) {
            tok[0] = '0';
            tok[1] = '.';
            tok[2] = 0;
            literal_tracking = 1;
            track_type = NUMERIC;
            tokpos = 2;
        }
        else if(!literal_tracking && !word_tracking) {
            if((line[i] == '+' || line[i] == '-' || line[i] == '*' || line[i] == '/' || line[i] == '%' || line[i] == '>' || line[i] == '<' || line[i] == '=')) {
                if(line[i + 1] == '+' || line[i + 1] == '-' || line[i + 1] == '=') {
                    char t[3];
                    t[0] = line[i];
                    t[1] = line[i + 1];
                    t[2] = 0;
                    if((t[1] == '+' && t[0] != '+') || (t[1] == '-' && t[0] != '-')) {
                        errors.push_back(Error("Invalid operator",currentLine)  );
                    }
                    tokens.qinsert(Token(t,OPERATOR));
                    i++;
                }
                else {
                    char t[2];
                    t[0] = line[i];
                    t[1] = 0;
                    tokens.qinsert(Token(t,OPERATOR));
                }
            }
            else if(line[i] == '(' || line[i] == ')' || line[i] == '[' || line[i] == ']' || line[i] == '{' || line[i] == '}' || line[i] == ',' || line[i] == ':' || line[i] == ';') {
                char t[2];
                t[0] = line[i];
                t[1] = 0;
                tokens.qinsert(Token(t,PUNCTUATOR));
            }
            else if(line[i] == '!' && line[i + 1] == '=') {
                tokens.qinsert(Token("!=",OPERATOR));
                i++;
            }
            else if(line[i] == '.') {
                tokens.qinsert(Token(".",OPERATOR) );
            }
            else if(line[i] == '!') {
                tokens.qinsert(Token("!",OPERATOR));
            }
        }
    }
    
    if(literal_tracking) {
        if(track_type == STRING) {
            errors.push_back(Error("Incomplete string",currentLine)  );
            interpretationSuccessful = 0;
        }
        else {
            tokens.qinsert(Token(tok,LITERAL,track_type));
            tok[0] = 0;
            tokpos = 0;
            literal_tracking = 0;
            track_type = UNKNOWN;
        }
    }
    if(word_tracking) {
        int type = getType(tok);
        if(type == VARIABLE || type == FUNCTION) {
            Token t(tok,IDENTIFIER,VARIABLE);
            tokens.qinsert( t );
        }
        else if(type == KEYWORD) {
            if(isIOFunction(tok)) tokens.qinsert(Token(tok,KEYWORD,IOFUNCTION));
            else tokens.qinsert(Token(tok,KEYWORD));
        }
        else if(type == OPERATOR) {
            tokens.qinsert(Token(tok,OPERATOR));
        }
        tok[0] = 0;
        tokpos = 0;
        word_tracking = 0;
    }
    return tokens;
}

/********** TOKENIZER: END **********/

/**********
 COMPONENT_2: RPN_GENERATOR
 DESCRIPTON:
 The above generated queue of tokens is used in this section of code to generate a postfix expression which is again a queue of tokens,
 but in the 'RPN' order. The control structures such as if,for and while are also considered "operators" which takes other RPN(s) as "parameters"
 to evaluate.
 
 


/*
 FUNCTION    : getFunction();
 DESCRIPTION : takes an identifier as parameter, returns a reference to a function found in the vector of functions.
 RETURNS     : Variable&
 PARAMETERS  : char[]
 */
Function getFunction(char s[]) {
    for(int i = 0;i < functions.size();i++) {
        if(strcmp(functions[i].getID(), s) == 0) return functions[i];
    }
    return Function();
}

/*
 FUNCTION    : priority();
 DESCRIPTION : takes a string as parameter, which is the operator, returns its relative priority. Used to compare priorities of operators.
 RETURNS     : int
 PARAMETERS  : char[]
 */
int priority(char s[]) {
    if((s[0] == '+' && s[1] == '+') || (s[0] == '-' && s[1] == '-') || s[0] == '.') {
        return 5;
    }
    else if((s[0] == '*' || s[0] == '/' || s[0] == '%') && s[1] == 0) {
        return 4;
    }
    else if((s[0] == '+' || s[0] == '-') && s[1] == 0) {
        return 3;
    }
    else if(strcmp(s,"==") == 0 || s[0] == '<' || s[0] == '>' || s[0] == '!') {
        return 2;
    }
    else if((s[0] == '=' && s[1] == 0) || strcmp(s,"and") == 0 || strcmp(s,"or") == 0 || s[1] == '=' || strcmp(s,"return") == 0) {
        return 1;
    }
    else return 0;
    
    
}

/*
 FUNCTION    : ifGenerate();
 DESCRIPTION : Called in convertToRPN() Takes the Queue of tokens, currently being processed in the convertToRPN() function, generates a cs_if object, returns it.
 RETURNS     : cs_if
 PARAMETERS  : Queue<Token>&
 */
cs_if ifGenerate(Queue<Token> &tokens) {
    Token t;
    tokens.qdelete(t);
    Queue<Token> condition,statements;
    if(t.value()[0] == '(') {
        int ifln = t.getLineNumber();
        tokens.qdelete(t);
        if(t.value()[0] == ')') {
            errors.push_back(Error("No Condition",ifln)  );
            interpretationSuccessful = 0;
        }
        else {
            int p = 1;
            condition.qinsert(t);
            while(p && tokens.qdelete(t)) {
                if(t.value()[0] == '(') p++;
                else if(t.value()[0] == ')') p--;
                if(p) condition.qinsert(t);
            }
            if(p) {
                errors.push_back(Error("Incomplete Condition, expected )",ifln)  );
                interpretationSuccessful = 0;
            }
            else {
                if(!tokens.qdelete(t)) {
                    errors.push_back(Error("No Statements",ifln)  );
                    interpretationSuccessful = 0;
                }
                if(t.value()[0] == '{') {
                    int p = 1;
                    while(p && tokens.qdelete(t)) {
                        if(t.value()[0] == '{') p++;
                        else if(t.value()[0] == '}') p--;
                        if(p) statements.qinsert(t);
                    }
                    if(p) {
                        errors.push_back(Error("Incomplete Statement, expected }",t.getLineNumber()));
                        interpretationSuccessful = 0;
                    }
                }
                else {
                    statements.qinsert(t);
                    while(t.value()[0] != ';') {
                        if(!tokens.qdelete(t)) {
                            errors.push_back(Error("Incomplete Statement, expected ;",t.getLineNumber()));
                            interpretationSuccessful = 0;
                            break;}
                        else {
                            statements.qinsert(t);
                        }
                    }
                }
            }
        }
        
    }
    else {
        errors.push_back(Error("Condition error: Expected (",t.getLineNumber())  );
        interpretationSuccessful = 0;
    }
    cs_if res;
    res.If_condition = convertToRPN(condition,variables.Top());
    res.If_statement = convertToRPN(statements,res.If_variables);
    if(strcmp(tokens.Front().value(),"else") == 0) {
        tokens.qdelete(t);
        tokens.qdelete(t);
        if(strcmp(t.value(),"if") == 0) {
            cs_if e = ifGenerate(tokens);
            ifs.push_back(e);
            char n[21];
            hashify((int)ifs.size() - 1,n);
            RPN r;
            r.qinsert(Token(n,HASHED));
            r.qinsert(t);
            res.Else_statement = r;
        }
        else if(t.value()[0] == '{') {
            Queue<Token> ts;
            int p = 1;
            while(p && tokens.qdelete(t)) {
                if(t.value()[0] == '{') p++;
                else if(t.value()[0] == '}') p--;
                if(p) ts.qinsert(t);
            }
            if(p) {
                errors.push_back(Error("Incomplete Statement(s),expected }",t.getLineNumber()));
                interpretationSuccessful = 0;
            }
            res.Else_statement = convertToRPN(ts,res.Else_variables);
        }
        else {
            Queue<Token> ts;
            ts.qinsert(t);
            while(t.value()[0] != ';') {
                if(!tokens.qdelete(t)) {
                    errors.push_back(Error("Incomplete Statement(s), expected ;",t.getLineNumber()));
                    interpretationSuccessful = 0;
                    break;
                }
                else {
                    ts.qinsert(t);
                }
            }
            res.Else_statement = convertToRPN(ts,res.Else_variables);
        }
    }
    
    return res;
}

/*
 FUNCTION    : forGenerate();
 DESCRIPTION : Called in convertToRPN() Takes the Queue of tokens, currently being processed in the convertToRPN() function, generates a cs_for object, returns it.
 RETURNS     : cs_for
 PARAMETERS  : Queue<Token>&
 */
cs_for forGenerate(Queue<Token> &tokens) {
    Token t;
    tokens.qdelete(t);
    cs_for res;
    Queue<Token> parameter,statements;
    if(t.value()[0] == '(') {
        tokens.qdelete(t);
        if(t.value()[0] == ')') {
            errors.push_back(Error("Invalid For Statement",t.getLineNumber()));
            interpretationSuccessful = 0;
        }
        else {
            int p = 1,forln = t.getLineNumber();
            parameter.qinsert(t);
            while(p && tokens.qdelete(t)) {
                if(t.value()[0] == '(') p++;
                else if(t.value()[0] == ')') p--;
                if(p) parameter.qinsert(t);
            }
            if(p) {
                errors.push_back(Error("Incomplete For statement, expected (",forln));
                interpretationSuccessful = 0;
            }
            else {
                if(!tokens.qdelete(t)) {
                    errors.push_back(Error("No Statements",forln)  );
                    interpretationSuccessful = 0;
                }
                if(t.value()[0] == '{') {
                    int p = 1;
                    while(p && tokens.qdelete(t)) {
                        if(t.value()[0] == '{') p++;
                        else if(t.value()[0] == '}') p--;
                        if(p) statements.qinsert(t);
                    }
                    if(p) {
                        errors.push_back(Error("Incomplete Statement(s), expected }",t.getLineNumber())  );
                        interpretationSuccessful = 0;
                    }
                }
                else {
                    statements.qinsert(t);
                    while(t.value()[0] != ';') {
                        if(!tokens.qdelete(t)) {
                            errors.push_back(Error("Incomplete Statement(s),expected ;",t.getLineNumber())  );
                            interpretationSuccessful = 0;
                            break;}
                        else {
                            statements.qinsert(t);
                        }
                    }
                }
            }
        }
        
    }
    else {
        errors.push_back(Error("Invalid For declaration",t.getLineNumber())  );
        interpretationSuccessful = 0;
    }
    int semicolons = 0;
    Queue<Token> temp;
    while(parameter.qdelete(t)) {
        if(t.value()[0] == ';') {
            semicolons++;
            if(semicolons == 1) {
                temp.qinsert(t);
                res.s1 = convertToRPN(temp,res.Counter_variables);
                variables.push(res.Counter_variables);
                temp.flush();
            }
            else if(semicolons == 2) {
                res.s2 = convertToRPN(temp,variables.Top());
                temp.flush();
            }
            else {
                errors.push_back(Error("Invalid For Declaration",t.getLineNumber())  );
                interpretationSuccessful = 0;
                break;
            }
        }
        else {
            temp.qinsert(t);
        }
    }
    if(semicolons == 2) {
        res.s3 = convertToRPN(temp,variables.Top());;
    }
    else {
        errors.push_back(Error("Invalid For Declaration",t.getLineNumber())  );
        interpretationSuccessful = 0;
    }
    res.statements = convertToRPN(statements,res.For_variables);
    variables.pop();
    return res;
}

Function functionGenerate(Queue<Token> &tokens) {
    Token id;
    tokens.qdelete(id);
    Token t;
    Queue<Token> parameter,statements;
    tokens.qdelete(t);
    int fnln = t.getLineNumber();
    if(t.value()[0] == '(') {
        tokens.qdelete(t);
        int p = 1;
        if(t.value()[0] != ')') {
            parameter.qinsert(t);
        }
        else {
            p = 0;
        }
        while(p && tokens.qdelete(t)) {
            if(t.value()[0] == '(') p++;
            else if(t.value()[0] == ')') p--;
            if(p) parameter.qinsert(t);
        }
        if(p) {
            errors.push_back(Error("Invalid Function Declaration,expected )",fnln)  );
            interpretationSuccessful = 0;
        }
        else {
            if(!tokens.qdelete(t)) {
                errors.push_back(Error("Invalid Function Declaration, expected statements",t.getLineNumber())  );
                interpretationSuccessful = 0;
            }
            if(t.value()[0] == '{') {
                p = 1;
                while(p && tokens.qdelete(t)) {
                    if(t.value()[0] == '{') p++;
                    else if(t.value()[0] == '}') p--;
                    if(p) statements.qinsert(t);
                }
                if(p) {
                    errors.push_back(Error("Invalid Function Declaration, expected }",t.getLineNumber())  );
                    interpretationSuccessful = 0;
                }
            }
            else {
                errors.push_back(Error("Invalid Function Declaration, expected {",t.getLineNumber())  );
                interpretationSuccessful = 0;
            }
        }
    }
    else {
        errors.push_back(Error("Invalid Function Declaration, expected (",t.getLineNumber())  );
        interpretationSuccessful = 0;
    }
    return Function(id.value(),parameter,statements);
}

/*
 FUNCTION    : convertToRPN();
 DESCRIPTION : Takes a Queue of tokens, converts it to Reverse Polish Notation returns it. Note: RPN is "typedef"ed as a Queue of tokens only.
 It makes use of an opertor stack to store the operators in the order of priority.It pops operators as needed.
 RETURNS     : RPN
 PARAMETERS  : Queue<Token>,Vector<Variable>&
 */
RPN convertToRPN(Queue<Token> tokens,Vector<Variable> &v) {
    RPN r;
    Token current;
    Stack<Token> operatorStack;
    while(tokens.qdelete(current)) {
        if(current.type() == UNKNOWN) {
            for(int i = 0;i < functions.size();i++) {
                if(strcmp(functions[i].getID(),current.value()) == 0) {
                    current.setType(IDENTIFIER);
                    current.setSubType(FUNCTION);
                }
            }
            if(current.type() == UNKNOWN && current.value()[0] != ';') {
                int isvar = 0;
                for(int i = 0;i <v.size() && !isvar;i++) {
                    if(strcmp(current.value(), v[i].getID()) == 0) isvar = 1;
                }
                if(isVariable(current.value()) || isvar) {
                    current.setType(IDENTIFIER);
                    current.setSubType(VARIABLE);
                }
                else {
                    errors.push_back(Error("Unknown Identifier",current.getLineNumber()) );
                    interpretationSuccessful = 0;
                }
            }
        }
        if(current.type() == DATATYPE) {
            int type_id;
            if(strcmp(current.value(),"Integer")  == 0) {
                type_id = INTEGER;
            }
            else if(strcmp(current.value(),"Numeric") == 0) {
                type_id = NUMERIC;
            }
            else if(strcmp(current.value(),"String") == 0) {
                type_id = STRING;
            }
            else if(strcmp(current.value(),"Char") == 0) {
                type_id = CHAR;
            }
            else if(strcmp(current.value(),"Boolean") == 0) {
                type_id = BOOLEAN;
            }
            else if(strcmp(current.value(),"Time") == 0) {
                type_id = TIME;
            }
            else if(strcmp(current.value(),"Date") == 0) {
                type_id = DATE;
            }
            int s = 0;
            int isArray = 0;
            if(tokens.Front().value()[0] == '[') {
                isArray = 1;
                Token t;
                tokens.qdelete(t);
                tokens.qdelete(t);
                if(t.type() == LITERAL && t.subType() == INTEGER) {
                    s = atoi(t.value());
                }
                else {
                    errors.push_back(Error("Array Declaration, must have constant integer as size",t.getLineNumber())  );
                    interpretationSuccessful = 0;
                }
                tokens.qdelete(t);
                if(t.value()[0] != ']') {
                    errors.push_back(Error("Invalid Array Declaration, expected ]",t.getLineNumber())  );
                    interpretationSuccessful = 0;
                }
            }
            
            Token t;
            while(true) {
                Token varName;
                if(!tokens.qdelete(t)) {
                    errors.push_back(Error("Expected ;",current.getLineNumber()));
                    interpretationSuccessful = 0;
                    break;
                }
                if(t.type() == UNKNOWN) {
                    v.push_back(Variable(t.value(),type_id,isArray,s));
                    varName = t;
                }
                else {
                    errors.push_back(Error("Invalid Identifier",current.getLineNumber()));
                    interpretationSuccessful = 0;
                    break;
                }
                tokens.qdelete(t);
                if(t.value()[0] == ';') break;
                if(t.value()[0] == ',') continue;
                else if(t.value()[0] == '=') {
                    Queue<Token> ts;
                    ts.qinsert(varName);
                    ts.qinsert(Token("=",OPERATOR) );
                    while(tokens.qdelete(t) && t.value()[0] != ',' && t.value()[0] != ';') {
                        ts.qinsert(t);
                    }
                    ts.qinsert(Token(";"));
                    RPN init = convertToRPN(ts,v);
                    Token t2;
                    while(init.qdelete(t2)) {
                        r.qinsert(t2);
                    }
                    if(tokens.isEmpty() && t.value()[0] != ';') {
                        errors.push_back(Error("Expected ;",current.getLineNumber()));
                        interpretationSuccessful = 0;
                    }
                    else if(t.value()[0] == ';') break;
                    
                }
                else {
                    errors.push_back(Error("Invalid statement",current.getLineNumber()));
                    interpretationSuccessful = 0;
                }
            }
            
        }
        else if(current.type() == KEYWORD) {
            if(current.subType() == IOFUNCTION) {
                Token t;
                Queue<Token> temp;
                int p = 1;
                if(!tokens.qdelete(t)) {
                    errors.push_back(Error("Incomplete function",t.getLineNumber())  );
                    interpretationSuccessful = 0;
                }
                else {
                    if(t.value()[0] == '(') {
                        int ioln = t.getLineNumber();
                        while(p && tokens.qdelete(t)) {
                            if(t.value()[0] == '(') {
                                p++;
                                temp.qinsert(t);
                            }
                            else if(t.value()[0] == ')') {
                                p--;
                                if(p) temp.qinsert(t);
                            }
                            else {
                                temp.qinsert(t);
                            }
                        }
                        if(p) {
                            errors.push_back(Error("Incomplete call, expected )",ioln)  );
                            interpretationSuccessful = 0;
                        }
                    }
                    else {
                        errors.push_back(Error("Invalid function call, expected (",t.getLineNumber())  );
                        interpretationSuccessful = 0;
                    }
                }
                
                if(temp.isEmpty()) {
                    temp.qinsert(Token("\"\"",LITERAL,STRING));
                }
                rpns.push_back(convertToRPN(temp,v));
                char n[21];
                hashify((int)rpns.size()-1, n);
                r.qinsert(Token(n,HASHED) );
                
                r.qinsert(current);
            }
            else if(strcmp(current.value(),"if") == 0 || strcmp(current.value(), "while") == 0) {
                char n[21];
                cs_if res = ifGenerate(tokens);
                ifs.push_back(res);
                hashify((int)ifs.size()-1,n);
                r.qinsert(Token(n,HASHED));
                r.qinsert(current);
            }
            else if(strcmp(current.value(),"for") == 0) {
                char n[21];
                cs_for res = forGenerate(tokens);
                fors.push_back(res);
                hashify((int)fors.size()-1,n);
                r.qinsert(Token(n,HASHED));
                r.qinsert(current);
            }
            else if(strcmp(current.value(), "function") == 0) {
                Function res = functionGenerate(tokens);
                functions.push_back(res);
            }
            else if(strcmp(current.value(),"true") == 0) {
                r.qinsert(Token("1",LITERAL,INTEGER));
            }
            else if(strcmp(current.value(),"false") == 0) {
                r.qinsert(Token("0",LITERAL,INTEGER));
            }
            else if(strcmp(current.value(),"length") == 0) {
                r.qinsert(current);
            }
        }
        else if(current.type() == LITERAL) {
            r.qinsert(current);
        }
        else if(current.subType() == VARIABLE) {
            r.qinsert(current);
        }
        else if(current.subType() == FUNCTION) {
            Token t;
            tokens.qdelete(t);
            Queue<Token> temp;
            if(t.value()[0] == '(') {
                int p = 1;
                int fln = t.getLineNumber();
                while(p && tokens.qdelete(t)) {
                    if(t.value()[0] == '(') p++;
                    else if(t.value()[0] == ')') p--;
                    if(p)  temp.qinsert(t);
                }
                if(!p) {
                    rpns.push_back(convertToRPN(temp,v));
                    char n[21];
                    hashify((int)rpns.size()-1, n);
                    r.qinsert(Token(n,HASHED) );
                    r.qinsert(current);
                }
                else {
                    errors.push_back(Error("Invalid function call, expected )",fln)  );
                    interpretationSuccessful = 0;
                }
            }
        }
        else if(current.value()[0] == ';') {
            Token t;
            while(operatorStack.pop(t)) {
                r.qinsert(t);
            }
            r.qinsert(current);
        }
        else if(current.type() == OPERATOR) {
            Token t;
            t = operatorStack.Top();
            while(priority(current.value()) <= priority(t.value())) {
                if(!operatorStack.pop(t)) break;
                r.qinsert(t);
                t = operatorStack.Top();
            }
            if((current.value()[0] == '+' && current.value()[1] == '+') || (current.value()[0] == '-' && current.value()[1] == '-')) {
                int type = getType(tokens.Front().value());
                if(type == VARIABLE) {
                    current.setSubType(PRE);
                }
                else {
                    current.setSubType(POST);
                }
            }
            
            operatorStack.push(current);
        }
        else if(current.type() == PUNCTUATOR) {
            if(current.value()[0] == '(') {
                operatorStack.push(current);
            }
            else if(current.value()[0] == ')') {
                Token t;
                while(operatorStack.pop(t) && t.value()[0] != '(') {
                    r.qinsert(t);
                }
                if(t.value()[0] != '(') {
                    errors.push_back(Error("Unbalanced parenthesis",t.getLineNumber())  );
                    interpretationSuccessful = 0;
                }
            }
            else if(current.value()[0] == ',') {
                r.qinsert(current);
            }
            else if(current.value()[0] == '[') {
                Token t;
                Queue<Token> temp;
                int p = 1;
                while(p && tokens.qdelete(t)) {
                    if(t.value()[0] == '[') p++;
                    else if(t.value()[0] == ']') p--;
                    if(p) temp.qinsert(t);
                }
                if(p) {
                    errors.push_back(Error("Expected ]",t.getLineNumber())  );
                    interpretationSuccessful = 0;
                }
                else {
                    rpns.push_back(convertToRPN(temp,variables.Top()));
                    char n[101];
                    hashify((int)rpns.size() - 1,n);
                    r.qinsert(Token(n,HASHED));
                    r.qinsert(Token("[]",OPERATOR));
                }
            }
        }
    }
    while (operatorStack.pop(current)) {
        r.qinsert(current);
    }
    return r;
}

/********** RPN_GENERATOR:END **********/

/**********
 COMPONENT_3 : RPN_EVALUATOR
 DESCRIPTION :
 This section of code takes the above generated queue of tokens(RPN form) and evaluates it. Some cases, RPNS may be needed
 as parameters for an operator. They are "hashed" and maintained in an  array of RPNs. The required RPN is extracted using functions
 defined in this section.
 
 **********/

/*
 FUNCTION    : getCharAt();
 DESCRIPTION : returns the character at the specified index for the string.
 RETURNS     : Token
 PARAMETERS  : stringChar
 */
Token getCharAt(stringChar s) {
    Token t = getVariable(s.v).value();
    if(s.i >= strlen(t.value()) - 2) {
        errors.push_back(Error("Runtime_Error: Out of Bounds access of character..",-1));
        interpretationSuccessful = 0;
        return t;
    }
    else {
        char v[5];
        v[0] = '\'';
        v[2] = '\'';
        v[3] = 0;
        v[1] = t.value()[s.i + 1];
        return Token(v,LITERAL,CHAR);
    }
}

/*
 FUNCTION    : setCharAt();
 DESCRIPTION : sets character at the required position of the string.
 RETURNS     : void
 PARAMETERS  : strincChar,char
 */
void setCharAt(stringChar s,char ch) {
    Token t = getVariable(s.v).value();
    if(s.i >= strlen(t.value()) - 2) {
        errors.push_back(Error("Runtime_Error: Out of Bounds access of character..",-1));
        interpretationSuccessful = 0;
    }
    else {
        char n[101];
        strcpy(n,getVariable(s.v).value().value());
        n[s.i + 1] = ch;
        getVariable(s.v).setValue(Token(n,LITERAL,STRING));
    }
}

/*
 FUNCTION    : add();
 DESCRIPTION : performs addition on the given two tokens.
 RETURNS     : Token
 PARAMETERS  : Token,Token
 */
Token add(Token a,Token b) {
    Token d;
    if(a.subType() == INTEGER && b.subType() == INTEGER) {
        int o1 = atoi(a.value());
        int o2 = atoi(b.value());
        d = convertIntegerToToken(o1 + o2);
    }
    else if( (a.subType() == NUMERIC && b.subType() == NUMERIC)  || (a.subType() == NUMERIC && b.subType() == INTEGER) || (a.subType() == INTEGER && b.subType() == NUMERIC) ) {
        double o1 = atof(a.value());
        double o2 = atof(b.value());
        d = convertNumericToToken(o1 + o2);
    }
    else if( (a.subType() == STRING && b.subType() == STRING) ) {
        char n[202],o1[101],o2[101];
        convertToString(a.value(),o1);
        convertToString(b.value(),o2);
        int i;
        n[0] = '"';
        for(i = 1;o1[i - 1];i++)
            n[i] = o1[i - 1];
        n[i] = 0;
        for(int j = 0; o2[j];i++,j++)
            n[i] = o2[j];
        n[i] = '"';
        n[i + 1] = 0;
        d = Token(n,LITERAL,STRING);
    }
    else if( a.subType() == STRING && b.subType() == CHAR) {
        char n[101] = "";
        strcpy(n,a.value());
        n[strlen(a.value()) - 1] = b.value()[1];
        n[strlen(a.value())] = '"';
        n[strlen(a.value()) + 1] = 0;
        d = Token(n,LITERAL,STRING);
    }
    else if(a.subType() == CHAR && b.subType() == STRING) {
        char n[101],o1[101];
        convertToString(b.value(), o1);
        n[0] = '"';
        n[1] = a.value()[1];
        n[2] = 0;
        strcat(n, o1);
        long int l = strlen(n);
        n[l] = '"';
        n[l + 1] = 0;
        d = Token(n,LITERAL,STRING);
    }
    else if(a.subType() == STRING && (b.subType() == INTEGER || b.subType() == NUMERIC)) {
        char n[101] = "";
        strcpy(n,a.value());
        n[strlen(n) - 1] = 0;
        strcat(n,b.value());
        long int l = strlen(n);
        n[l] = '"';
        n[l + 1] = 0;
        d = Token(n,LITERAL,STRING);
    }
    else if((a.subType() == INTEGER || a.subType() == NUMERIC) && b.subType() == STRING) {
        char n[101] = "";
        n[0] = '"';
        n[1] = 0;
        strcat(n,a.value());
        char o1[101];
        convertToString(b.value(), o1);
        strcat(n,o1);
        strcat(n,"\"");
        d = Token(n,LITERAL,STRING);
    }
    else if(a.subType() == INTEGER && b.subType() == CHAR) {
        char n[5];
        strcpy(n,b.value());
        n[1]+= atoi(a.value());
        d = Token(n,LITERAL,CHAR);
    }
    else if(a.subType() == CHAR && b.subType() == INTEGER) {
        char n[5];
        strcpy(n,a.value());
        n[1]+= atoi(b.value());
        d = Token(n,LITERAL,CHAR);
    }
    else if(a.subType() == TIME && b.subType() == TIME) {
        Time t1,t2;
        t1 = times[getIndexOfHash(a.value())];
        t2 = times[getIndexOfHash(b.value())];
        t1 = t1 + t2;
        times.push_back(t1);
        char n[101];
        hashify((int)times.size() - 1,n);
        d = Token(n,LITERAL,TIME);
    }
    else if(a.subType() == DATE && b.subType() == INTEGER) {
        Date d1 = dates[getIndexOfHash(a.value())];
        int d2 = atoi(b.value());
        d1 = d1 + d2;
        dates.push_back(d1);
        char n[101];
        hashify((int)dates.size() - 1,n);
        d = Token(n,LITERAL,DATE);
    }
    else if(a.subType() == INTEGER && b.subType() == DATE) {
        Date d1 = dates[getIndexOfHash(b.value())];
        int d2 = atoi(a.value());
        d1 = d1 + d2;
        dates.push_back(d1);
        char n[101];
        hashify((int)dates.size() - 1,n);
        d = Token(n,LITERAL,DATE);
    }
    else {
        errors.push_back(Error("Runtime_Error: Invalid operands for addition",-1));
    }
    return d;
}

/*
 FUNCTION    : subtract();
 DESCRIPTION : performs addition on the given two tokens. String additions, are concatenations.
 RETURNS     : Token
 PARAMETERS  : Token,Token
 */
Token subtract(Token a,Token b) {
    Token d;
    if(a.subType() == INTEGER && b.subType() == INTEGER) {
        int o1 = atoi(a.value());
        int o2 = atoi(b.value());
        d = convertIntegerToToken(o1 - o2);
    }
    else if( (a.subType() == NUMERIC && b.subType() == NUMERIC)  || (a.subType() == NUMERIC && b.subType() == INTEGER) || (a.subType() == INTEGER && b.subType() == NUMERIC) ) {
        double o1 = atof(a.value());
        double o2 = atof(b.value());
        d = convertNumericToToken(double(o1 - o2));
    }
    else if(a.subType() == TIME && b.subType() == TIME) {
        Time t1,t2;
        t1 = times[getIndexOfHash(a.value())];
        t2 = times[getIndexOfHash(b.value())];
        t1 = t1 - t2;
        times.push_back(t1);
        char n[101];
        hashify((int)times.size() - 1,n);
        d = Token(n,LITERAL,TIME);
    }
    else {
        errors.push_back(Error("Runtime_Error: Invalid operands for subtraction",-1));
    }
    return d;
}

/*
 FUNCTION    : multiply();
 DESCRIPTION : performs subtraction on the given two tokens.
 RETURNS     : Token
 PARAMETERS  : Token,Token
 */
Token multiply(Token a,Token b) {
    Token d;
    if(a.subType() == INTEGER && b.subType() == INTEGER) {
        int o1 = atoi(a.value());
        int o2 = atoi(b.value());
        d = convertIntegerToToken(o1 * o2);
    }
    else if( (a.subType() == NUMERIC && b.subType() == NUMERIC)  || (a.subType() == NUMERIC && b.subType() == INTEGER) || (a.subType() == INTEGER && b.subType() == NUMERIC) ) {
        double o1 = atof(a.value());
        double o2 = atof(b.value());
        d = convertNumericToToken(o1 * o2);
    }
    else {
        errors.push_back(Error("Runtime_Error: Invalid operands for multiplication",-1));
    }
    return d;
}

/*
 FUNCTION    : divide();
 DESCRIPTION : performs multiplication on the given two tokens.
 RETURNS     : Token
 PARAMETERS  : Token,Token
 */
Token divide(Token a,Token b) {
    Token d;
    if(a.subType() == INTEGER && b.subType() == INTEGER) {
        int o1 = atoi(a.value());
        int o2 = atoi(b.value());
        if(o2 == 0) {
            errors.push_back(Error("Runtime_Error: Division by zero",-1));
        }
        else d = convertIntegerToToken(o1 / o2);
    }
    else if( (a.subType() == NUMERIC && b.subType() == NUMERIC)  || (a.subType() == NUMERIC && b.subType() == INTEGER) || (a.subType() == INTEGER && b.subType() == NUMERIC) ) {
        double o1 = a.subType() == NUMERIC ?  atof(a.value()) : atoi(a.value());
        double o2 = b.subType() == NUMERIC ?  atof(b.value()) : atoi(b.value());
        if(o2 == 0) {
            errors.push_back(Error("Runtime_Error: Division by zero",-1));
        }
        else d = convertNumericToToken(o1/o2);
    }
    else {
        errors.push_back(Error("Runtime_Error: Invalid operands for division",-1));
    }
    return d;
}

/*
 FUNCTION    : modulo();
 DESCRIPTION : performs division on the given two tokens.
 RETURNS     : Token
 PARAMETERS  : Token,Token
 */
Token modulo(Token a,Token b) {
    Token d;
    if(a.subType() == INTEGER && b.subType() == INTEGER) {
        int o1 = atoi(a.value());
        int o2 = atoi(b.value());
        if(o2 == 0) {
            errors.push_back(Error("Runtime_Error: Modulo with zero",-1));
        }
        else d = convertIntegerToToken(o1 % o2);
    }
    else {
        errors.push_back(Error("Runtime_Error: Invalid operands for modulus",-1));
    }
    return d;
}

/*
 FUNCTION    : Compare();
 DESCRIPTION : performs different comparisions on the given two tokens. The string parameter is the operator.
 RETURNS     : Token
 PARAMETERS  : Token,Token,char[]
 */
Token Compare(Token a,Token b,char op[]) {
    int res = 0;
    if(a.subType() == INTEGER && b.subType() == INTEGER)  {
        int o1 = atoi(a.value());
        int o2 = atoi(b.value());
        if(strcmp(op,">") == 0 && o1 > o2) res = 1;
        else if(strcmp(op,">=") == 0 && o1 >= o2) res = 1;
        else if(strcmp(op,"<") == 0 && o1 < o2) res = 1;
        else if(strcmp(op,"<=") == 0 && o1 <= o2) res = 1;
    }
    else if( (a.subType() == NUMERIC && b.subType() == NUMERIC)  || (a.subType() == NUMERIC && b.subType() == INTEGER) || (a.subType() == INTEGER && b.subType() == NUMERIC) ) {
        double o1 = atof(a.value());
        double o2 = atof(b.value());
        if(strcmp(op,">") == 0 && o1 > o2) res = 1;
        else if(strcmp(op,">=") == 0 && o1 >= o2) res = 1;
        else if(strcmp(op,"<") == 0 && o1 < o2) res = 1;
        else if(strcmp(op,"<=") == 0 && o1 <= o2) res = 1;
    }
    else if(a.subType() == TIME && b.subType() == TIME) {
        Time o1 = times[getIndexOfHash(a.value())];
        Time o2 = times[getIndexOfHash(b.value())];
        if(strcmp(op,">") == 0 && o1 > o2) res = 1;
        else if(strcmp(op,">=") == 0 && o1 >= o2) res = 1;
        else if(strcmp(op,"<") == 0 && o1 < o2) res = 1;
        else if(strcmp(op,"<=") == 0 && o1 <= o2) res = 1;
    }
    else if(a.subType() == DATE && b.subType() == DATE) {
        Date o1 = dates[getIndexOfHash(a.value())];
        Date o2 = dates[getIndexOfHash(b.value())];
        if(strcmp(op,">") == 0 && o1 > o2) res = 1;
        else if(strcmp(op,">=") == 0 && o1 >= o2) res = 1;
        else if(strcmp(op,"<") == 0 && o1 < o2) res = 1;
        else if(strcmp(op,"<=") == 0 && o1 <= o2) res = 1;
    }
    char n[2];
    n[0] = res + '0';
    n[1] = 0;
    return Token(n,LITERAL,INTEGER);
}

#define tab '\t'
#define wall '|'

#define TAB 8
#define WALL 1

void fillRestOfLine(int n) {
    for(int i = 0;i < 75 - n - 1;i++) cout<<' ';
    cout<<wall<<endl;
}

/*
 FUNCTION    : io_write();
 DESCRIPTION : writes the given token to the console.
 RETURNS     : void
 PARAMETERS  : Token
 */
void io_write(Token t) {
    if(t.type() == LITERAL) {
        if(t.subType() == INTEGER || t.subType() == NUMERIC) {
            cout<<t.value();
        }
        else if(t.subType() == CHAR) {
            cout<<t.value()[1];
        }
        else if(t.subType() == STRING) {
            char s[101];
            convertToString(t.value(),s);
            cout<<s;
        }
        else if(t.subType() == TIME) {
            times[getIndexOfHash(t.value())].display();
        }
        else if(t.subType() == DATE) {
            dates[getIndexOfHash(t.value())].display();
        }
    }
}

//Used to track the number of cins called. If it is positive, cin.get() is used in case readLine is called.w
int cinUsed = 0;

/*
 FUNCTION    : io_readInteger();
 DESCRIPTION : reads an integer from the console. The function ensures that an integer is entered.
 RETURNS     : Token
 PARAMETERS  : (none)
 */
Token io_readInteger() {
    cinUsed++;
    char n[101];
    cin>>n;
    int isInteger = 1;
    for(int i = 0;isInteger && n[i];i++) {
        if(i == 0 && n[i] == '-') continue;
        if(!isdigit(n[i])) isInteger = 0;
    }
    while(!isInteger) {
        cout<<"Enter an integer: ";
        cin>>n;
        isInteger = 1;
        for(int i = 0;isInteger && n[i];i++) {
            if(!isdigit(n[i])) isInteger = 0;
        }
    }
    return Token(n,LITERAL,INTEGER);
}

/*
 FUNCTION    : io_readNumeric();
 DESCRIPTION : reads a numeric from the console. The function ensures that a numeric value is entered.
 RETURNS     : Token
 PARAMETERS  : (none)
 */
Token io_readNumeric() {
    cinUsed++;
    char n[101];
    n[0] = 0;
    cin>>n;
    int isNumeric = 1;
    int p = 0;
    for(int i  = 0;n[i] && isNumeric;i++) {
        if(!isdigit(n[i]) && n[i] != '.') isNumeric = 0;
        if(n[i] == '.') p++;
        if(p > 1) isNumeric = 0;
    }
    while(!isNumeric) {
        cout<<"Enter a numeric: ";
        n[0] = 0;
        cin>>n;
        isNumeric = 1;
        p = 0;
        for(int i  = 0;n[i] && isNumeric;i++) {
            if(!isdigit(n[i]) && n[i] != '.') isNumeric = 0;
            if(n[i] == '.') p++;
            if(p > 1) isNumeric = 0;
        }
    }
    return Token(n,LITERAL,NUMERIC);
}

/*
 FUNCTION    : io_readTime();
 DESCRIPTION : reads a time entered by the user.
 RETURNS     : Token
 PARAMETERS  : (none)
 */

Token io_readTime() {
    int h,m,s;
    cout<<"Enter hours: ";
    h = atoi(io_readInteger().value());
    while(h > 23  || h < 0) {
        cout<<"Enter a valid value: ";
        h = atoi(io_readInteger().value());
    }
    cout<<"Enter minutes: ";
    m = atoi(io_readInteger().value());
    while(m > 59 || m <  0) {
        cout<<"Enter a valid value: ";
        m = atoi(io_readInteger().value());
    }
    cout<<"Enter seconds: ";
    s = atoi(io_readInteger().value());
    while(s > 59 && s < 0) {
        cout<<"Enter a valid value: ";
        s = atoi(io_readInteger().value());
    }
    Time t(h,m,s);
    times.push_back(t);
    char n[101];
    hashify((int)times.size() - 1,n);
    return Token(n,LITERAL,TIME);
}

/*
 FUNCTION    : io_readLine();
 DESCRIPTION : reads a line of string from the console.
 RETURNS     : Token
 PARAMETERS  : (none)
 */
Token io_readLine() {
    if(cinUsed) {
        cin.get();
        cinUsed = 0;
    }
    char n[101];
    cin.getline(n,101);
    char a[101];
    a[0] = '"';
    a[1] = 0;
    strcat(a,n);
    strcat(a,"\"");
    return Token(a,LITERAL,STRING);
}

/*
 FUNCTION    : io_read();
 DESCRIPTION : reads a string from the console.
 RETURNS     : Token
 PARAMETERS  : (none)
 */
Token io_read() {
    cinUsed++;
    char n[101];
    cin>>n;
    char a[101];
    a[0] = '"';
    a[1] = 0;
    strcat(a,n);
    strcat(a,"\"");
    return Token(a,LITERAL,STRING);
}

Token io_readDate() {
    int d,m,y;
    cout<<"Enter day: ";
    d = atoi(io_readInteger().value());
    while(d > 31  || d < 0) {
        cout<<"Enter a valid value: ";
        d = atoi(io_readInteger().value());
    }
    cout<<"Enter month (1 - 12): ";
    m = atoi(io_readInteger().value());
    while(m > 12 || m <  0) {
        cout<<"Enter a valid value: ";
        m = atoi(io_readInteger().value());
    }
    cout<<"Enter year: ";
    y = atoi(io_readInteger().value());
    while(y < 0) {
        cout<<"Enter a valid value: ";
        y = atoi(io_readInteger().value());
    }
    Date t(d,m - 1,y);
    dates.push_back(t);
    char n[101];
    hashify((int)dates.size() - 1,n);
    return Token(n,LITERAL,DATE);
}

/*
 FUNCTION    : isBinaryOperator;
 DESCRIPTION : returns a boolean value, stating whether the given parameter is a binary operator.
 RETURNS     : int
 PARAMETERS  : char[]
 */
int isBinaryOperator(char n[]) {
    if(strcmp(n,"+") == 0 ||
       strcmp(n,"-") == 0 ||
       strcmp(n,"*") == 0 ||
       strcmp(n,"/") == 0 ||
       strcmp(n,"=") == 0 ||
       strcmp(n,"%") == 0 ||
       strcmp(n,"+=") == 0 ||
       strcmp(n,"-=") == 0 ||
       strcmp(n,"*=") == 0 ||
       strcmp(n,"/=") == 0 ||
       strcmp(n,"%=") == 0 ||
       strcmp(n,">") == 0 ||
       strcmp(n,"<") == 0 ||
       strcmp(n,">=") == 0 ||
       strcmp(n,"<=") == 0 ||
       strcmp(n,"==") == 0 ||
       strcmp(n,"!=") == 0 ||
       strcmp(n,"and") == 0 ||
       strcmp(n,"or") == 0 ||
       strcmp(n,"[]") == 0 ||
       strcmp(n,".") == 0
       ) return 1;
    return 0;
}


/*
 FUNCTION    : checkRPN();
 DESCRIPTION : checks whether the given RPN is valid, all operators have the required number of operands etc.. modifies the global varibale interpretationSuccessful accordingly.
 RETURNS     : void
 PARAMETERS  : RPN
 */
void checkRPN(RPN r) {
    Token curr;
    Stack<Token> operandStack;
    while(r.qdelete(curr)) {
        if(curr.value()[0] == ';') {
            operandStack.flush();
        }
        else if(curr.type() == LITERAL || curr.subType() == VARIABLE || curr.type() == HASHED || strcmp(curr.value(),"length") == 0 ) {
            operandStack.push(curr);
        }
        else if(curr.subType() == FUNCTION) {
            Token t;
            operandStack.pop(t);
            currentLine = curr.getLineNumber();
            getFunction(curr.value()).checkFunction(rpns[getIndexOfHash(t.value())]);
            operandStack.push(curr);
        }
        else if(curr.type() == OPERATOR) {
            if(isBinaryOperator(curr.value()))  {
                Token a,b;
                if(!operandStack.pop(b)) {
                    errors.push_back(Error("Insufficient operands",curr.getLineNumber()));
                    interpretationSuccessful = 0;
                }
                if(!operandStack.pop(a))  {
                    errors.push_back(Error("Insufficient operands",curr.getLineNumber()));
                    interpretationSuccessful = 0;
                }
                if(strcmp(curr.value(),"=") == 0) {
                    if(a.subType() != VARIABLE && a.subType() != ARRAYELEM && a.subType() != STRINGCHAR) {
                        errors.push_back(Error("Invalid assignment",a.getLineNumber()));
                        interpretationSuccessful = 0;
                    }
                }
                operandStack.push(a);
            }
            else if(strcmp(curr.value(),"!") == 0) {
                Token a;
                if(!operandStack.pop(a)) {
                    errors.push_back(Error("Insufficient operands",a.getLineNumber()));
                    interpretationSuccessful = 0;
                }
                operandStack.push(a);
            }
        }
        else if(curr.type() == KEYWORD) {
            if(curr.subType() == IOFUNCTION) {
                if(strcmp(curr.value(), "write") == 0 || strcmp(curr.value(),"writeLine") == 0) {
                    Token t;
                    operandStack.pop(t);
                    checkRPN(rpns[ getIndexOfHash( t.value() ) ] );
                }
                else if(strcmp(curr.value(),"readInteger") == 0 || strcmp(curr.value(), "readNumeric") == 0) {
                    Token s;
                    operandStack.pop(s);
                    checkRPN(rpns[ getIndexOfHash( s.value() ) ] );
                    Token t("0",LITERAL,INTEGER);
                    operandStack.push(t);
                }
                else if(strcmp(curr.value(),"read") == 0 || strcmp(curr.value(), "readLine") == 0) {
                    Token s;
                    operandStack.pop(s);
                    checkRPN(rpns[ getIndexOfHash( s.value() ) ] );
                    Token t("\"\"",LITERAL,STRING);
                    operandStack.push(t);
                }
                else if(strcmp(curr.value(),"readTime") == 0) {
                    Token t;
                    operandStack.pop(t);
                    checkRPN(rpns[ getIndexOfHash( t.value() ) ] );
                    operandStack.push(Token("",LITERAL,TIME) );
                }
            }
            else if(strcmp(curr.value(), "if") == 0) {
                Token c;
                operandStack.pop(c);
                checkRPN(ifs[getIndexOfHash(c.value())].If_condition);
                checkRPN(ifs[getIndexOfHash(c.value())].If_statement);
                checkRPN(ifs[getIndexOfHash(c.value())].Else_statement);
            }
            else if(strcmp(curr.value(),"while") == 0) {
                Token c;
                operandStack.pop(c);
                checkRPN(ifs[getIndexOfHash(c.value())].If_condition);
                checkRPN(ifs[getIndexOfHash(c.value())].If_statement);
            }
            else if(strcmp(curr.value(),"for") == 0) {
                Token c;
                operandStack.pop(c);
                checkRPN(fors[getIndexOfHash(c.value())].s1);
                checkRPN(fors[getIndexOfHash(c.value())].s2);
                checkRPN(fors[getIndexOfHash(c.value())].s3);
                checkRPN(fors[getIndexOfHash(c.value())].statements);
            }
        }
    }
    Token e;
    operandStack.pop(e);
    if(operandStack.pop(e)) {
        errors.push_back(Error("Extra operand(s)",e.getLineNumber()));
        interpretationSuccessful = 0;
    }
}

/*
 FUNCTION    : evaluateRPN();
 DESCRIPTION : evaluates the given RPN.
 RETURNS     : Token
 PARAMETERS  : RPN
 */
Token evaluateRPN(RPN r) {
    Token curr;
    Stack<Token> operandStack;
    while(r.qdelete(curr) && errors.size() == 0) {
        if(!functionStack.isEmpty()) {
            if(functionStack.Top().hasReturned()) break;
        }
        if(curr.value()[0] == ';') {
            operandStack.flush();
        }
        else if(curr.type() == LITERAL || curr.subType() == VARIABLE || curr.type() == HASHED || strcmp(curr.value(),"length") == 0) {
            operandStack.push(curr);
        }
        else if(curr.subType() == FUNCTION) {
            Token t;
            operandStack.pop(t);
            Token r = getFunction(curr.value()).execute( rpns[getIndexOfHash(t.value())] );
            if(r.value()[0]) operandStack.push(r);
        }
        else if(curr.type() == OPERATOR) {
            if(curr.value()[0] == '+' && curr.value()[1] == 0) {
                Token a,b;
                operandStack.pop(b);
                operandStack.pop(a);
                Token d;
                if(a.subType() == VARIABLE)
                    a = getVariable(a.value()).value();
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    a = getVariable(e.v).value(e.i);
                }
                else if(a.subType() == STRINGCHAR) {
                    stringChar e  = stringChars[ getIndexOfHash(a.value())];
                    a = getCharAt(e);
                }
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                else if(b.subType() == STRINGCHAR) {
                    stringChar e  = stringChars[ getIndexOfHash(b.value())];
                    b = getCharAt(e);
                }
                operandStack.push(add(a,b));
                
            }
            else if(curr.value()[0] == '-' && curr.value()[1] == 0) {
                Token a,b;
                operandStack.pop(b);
                operandStack.pop(a);
                Token d;
                if(a.subType() == VARIABLE)
                    a = getVariable(a.value()).value();
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    a = getVariable(e.v).value(e.i);
                }
                else if(a.subType() == STRINGCHAR) {
                    stringChar e  = stringChars[ getIndexOfHash(a.value())];
                    a = getCharAt(e);
                }
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                else if(b.subType() == STRINGCHAR) {
                    stringChar e  = stringChars[ getIndexOfHash(b.value())];
                    b = getCharAt(e);
                }
                operandStack.push(subtract(a,b));
            }
            else if(curr.value()[0] == '*' && curr.value()[1] == 0) {
                Token a,b;
                operandStack.pop(b);
                operandStack.pop(a);
                Token d;
                if(a.subType() == VARIABLE)
                    a = getVariable(a.value()).value();
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    a = getVariable(e.v).value(e.i);
                }
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                operandStack.push(multiply(a,b));
            }
            else if(curr.value()[0] == '/' && curr.value()[1] == 0) {
                Token a,b;
                operandStack.pop(b);
                operandStack.pop(a);
                Token d;
                if(a.subType() == VARIABLE)
                    a = getVariable(a.value()).value();
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    a = getVariable(e.v).value(e.i);
                }
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                operandStack.push(divide(a, b));
            }
            else if(curr.value()[0] == '%' && curr.value()[1] == 0) {
                Token a,b;
                operandStack.pop(b);
                operandStack.pop(a);
                Token d;
                if(a.subType() == VARIABLE)
                    a = getVariable(a.value()).value();
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    a = getVariable(e.v).value(e.i);
                }
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                operandStack.push(modulo(a,b));
            }
            else if(curr.value()[0] == '=' && curr.value()[1] == 0) {
                Token a;
                Token b;
                operandStack.pop(b);
                operandStack.pop(a);
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                else if(b.subType() == STRINGCHAR) {
                    stringChar e = stringChars[getIndexOfHash(b.value())];
                    b = getCharAt(e);
                }
                if(a.subType() == VARIABLE) getVariable(a.value()).setValue(b);
                else if(a.subType() == ARRAYELEM){
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    getVariable(e.v).setValue(b,e.i);
                }
                else if(a.subType() == STRINGCHAR) {
                    stringChar e = stringChars[getIndexOfHash(a.value())];
                    setCharAt(e,convertToCharacter(b.value()));
                }
                operandStack.push(b);
                
            }
            else if(curr.value()[0] == '+' && curr.value()[1] == '=') {
                Token a;
                Token b;
                operandStack.pop(b);
                operandStack.pop(a);
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                else if(b.subType() == STRINGCHAR) {
                    stringChar e  = stringChars[ getIndexOfHash(b.value())];
                    b = getCharAt(e);
                }
                if(a.subType() == VARIABLE) getVariable(a.value()).setValue(add(  getVariable(a.value()).value(), b ) );
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    getVariable(e.v).setValue( add(b,getVariable(e.v).value(e.i)) ,e.i);
                }
                else if(a.subType() == STRINGCHAR) {
                    stringChar e = stringChars[getIndexOfHash(a.value())];
                    setCharAt(e,convertToCharacter( add(b,getVariable(e.v).value(e.i)).value()));
                }
                operandStack.push(b);
                
            }
            else if(curr.value()[0] == '-' && curr.value()[1] == '=') {
                Token a;
                Token b;
                operandStack.pop(b);
                operandStack.pop(a);
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                else if(b.subType() == STRINGCHAR) {
                    stringChar e  = stringChars[ getIndexOfHash(b.value())];
                    b = getCharAt(e);
                }
                if(a.subType() == VARIABLE) getVariable(a.value()).setValue(subtract(  getVariable(a.value()).value(), b ) );
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    getVariable(e.v).setValue( subtract(b,getVariable(e.v).value(e.i)) ,e.i);
                }
                else if(a.subType() == STRINGCHAR) {
                    stringChar e = stringChars[getIndexOfHash(a.value())];
                    setCharAt(e,convertToCharacter( subtract(b,getVariable(e.v).value(e.i)).value()));
                }
                operandStack.push(b);
                
            }
            else if(curr.value()[0] == '*' && curr.value()[1] == '=') {
                Token a;
                Token b;
                operandStack.pop(b);
                operandStack.pop(a);
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                if(a.subType() == VARIABLE) getVariable(a.value()).setValue(multiply(  getVariable(a.value()).value(), b ) );
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    getVariable(e.v).setValue( multiply(b,getVariable(e.v).value(e.i)) ,e.i);
                }
                operandStack.push(b);
                
            }
            else if(curr.value()[0] == '/' && curr.value()[1] == '=') {
                Token a;
                Token b;
                operandStack.pop(b);
                operandStack.pop(a);
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                if(a.subType() == VARIABLE) getVariable(a.value()).setValue(divide(  getVariable(a.value()).value(), b ) );
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    getVariable(e.v).setValue( divide(b,getVariable(e.v).value(e.i)) ,e.i);
                }
                operandStack.push(b);
                
            }
            else if(curr.value()[0] == '%' && curr.value()[1] == '=') {
                Token a;
                Token b;
                operandStack.pop(b);
                operandStack.pop(a);
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                if(a.subType() == VARIABLE) getVariable(a.value()).setValue(modulo(  getVariable(a.value()).value(), b ) );
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    getVariable(e.v).setValue( modulo(b,getVariable(e.v).value(e.i)) ,e.i);
                }                operandStack.push(b);
                
            }
            else if(curr.value()[0] == '+' && curr.value()[0] == '+') {
                if(curr.subType() == POST) {
                    Token a;
                    operandStack.pop(a);
                    Token old;
                    if(a.subType() == VARIABLE) old = getVariable(a.value()).value();
                    else if(a.subType() == ARRAYELEM) {
                        arrayElem e = arrayElems[getIndexOfHash(a.value())];
                        old = getVariable(e.v).value(e.i);
                    }
                    else {
                        stringChar e = stringChars[getIndexOfHash(a.value())];
                        old = getCharAt(e);
                    }
                    Token s = add(old,Token("1",LITERAL,INTEGER));
                    if(a.subType() == VARIABLE) getVariable(a.value()).setValue( s );
                    else if(a.subType() == ARRAYELEM) {
                        arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                        getVariable(e.v).setValue(s, e.i);
                    }
                    else if(a.subType() == STRINGCHAR) {
                        stringChar e = stringChars[getIndexOfHash(a.value())];
                        setCharAt(e,convertToCharacter(s.value()));
                    }
                    
                    operandStack.push(old);
                }
                else if(curr.subType() == PRE) {
                    Token a;
                    operandStack.pop(a);
                    Token old;
                    if(a.subType() == VARIABLE) old = getVariable(a.value()).value();
                    else if(a.subType() == ARRAYELEM) {
                        arrayElem e = arrayElems[getIndexOfHash(a.value())];
                        old = getVariable(e.v).value(e.i);
                    }
                    else {
                        stringChar e = stringChars[getIndexOfHash(a.value())];
                        old = getCharAt(e);
                    }
                    Token s = add(old,Token("1",LITERAL,INTEGER));
                    if(a.subType() == VARIABLE) getVariable(a.value()).setValue( s );
                    else if(a.subType() == ARRAYELEM) {
                        arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                        getVariable(e.v).setValue(s, e.i);
                    }
                    operandStack.push(variables.Top()[getIndexOfHash(a.value())].value());
                }
                
            }
            else if(curr.value()[0] == '-' && curr.value()[1] == '-') {
                if(curr.subType() == POST) {
                    Token a;
                    operandStack.pop(a);
                    Token old;
                    if(a.subType() == VARIABLE) old = getVariable(a.value()).value();
                    else if(a.subType() == ARRAYELEM) {
                        arrayElem e = arrayElems[getIndexOfHash(a.value())];
                        old = getVariable(e.v).value(e.i);
                    }
                    else {
                        stringChar e = stringChars[getIndexOfHash(a.value())];
                        old = getCharAt(e);
                    }
                    Token s = subtract(old,Token("1",LITERAL,INTEGER));
                    if(a.subType() == VARIABLE) getVariable(a.value()).setValue( s );
                    else if(a.subType() == ARRAYELEM) {
                        arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                        getVariable(e.v).setValue(s, e.i);
                    }
                    operandStack.push(old);
                }
                else if(curr.subType() == PRE) {
                    Token a;
                    operandStack.pop(a);
                    Token old;
                    if(a.subType() == VARIABLE) old = getVariable(a.value()).value();
                    else if(a.subType() == ARRAYELEM) {
                        arrayElem e = arrayElems[getIndexOfHash(a.value())];
                        old = getVariable(e.v).value(e.i);
                    }
                    else {
                        stringChar e = stringChars[getIndexOfHash(a.value())];
                        old = getCharAt(e);
                    }
                    Token s = subtract(old,Token("1",LITERAL,INTEGER));
                    if(a.subType() == VARIABLE) getVariable(a.value()).setValue( s );
                    else if(a.subType() == ARRAYELEM) {
                        arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                        getVariable(e.v).setValue(s, e.i);
                    }
                    else if(a.subType() == STRINGCHAR) {
                        stringChar e = stringChars[getIndexOfHash(a.value())];
                        setCharAt(e,convertToCharacter( s.value()));
                    }
                    operandStack.push(variables.Top()[getIndexOfHash(a.value())].value());
                }
            }
            else if(strcmp(curr.value(), "==") == 0) {
                Token a,b;
                operandStack.pop(b);
                operandStack.pop(a);
                Token d;
                if(a.subType() == VARIABLE)
                    a = getVariable(a.value()).value();
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    a = getVariable(e.v).value(e.i);
                }
                else if(a.subType() == STRINGCHAR) {
                    stringChar e  = stringChars[ getIndexOfHash(a.value())];
                    a = getCharAt(e);
                }
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                else if(b.subType() == STRINGCHAR) {
                    stringChar e  = stringChars[ getIndexOfHash(b.value())];
                    b = getCharAt(e);
                }
                char n[2];
                n[0] = '0' + (strcmp(a.value(),b.value()) == 0 ? 1 : 0);
                n[1] = 0;
                operandStack.push(Token(n,LITERAL,INTEGER) );
            }
            else if(strcmp( curr.value(),"!=") == 0 ) {
                Token a,b;
                operandStack.pop(b);
                operandStack.pop(a);
                Token d;
                if(a.subType() == VARIABLE)
                    a = getVariable(a.value()).value();
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    a = getVariable(e.v).value(e.i);
                }
                else if(a.subType() == STRINGCHAR) {
                    stringChar e  = stringChars[ getIndexOfHash(a.value())];
                    a = getCharAt(e);
                }
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                else if(b.subType() == STRINGCHAR) {
                    stringChar e  = stringChars[ getIndexOfHash(b.value())];
                    b = getCharAt(e);
                }
                
                char n[2];
                n[0] = '0' + (strcmp(a.value(),b.value()) != 0 ? 1 : 0);
                n[1] = 0;
                operandStack.push(Token(n,LITERAL,INTEGER) );
            }
            else if(strcmp(curr.value(),"!") == 0) {
                Token a;
                operandStack.pop(a);
                if(a.subType() == VARIABLE)
                    a = getVariable(a.value()).value();
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    a = getVariable(e.v).value(e.i);
                }
                Token d;
                if(a.subType() == INTEGER || a.subType() == NUMERIC || a.subType() == BOOLEAN ) {
                    if(strcmp(a.value(),"0") == 0 || strcmp(a.value(),"0.0") == 0) {
                        operandStack.push(Token("1",LITERAL,INTEGER));
                    }
                    else {
                        operandStack.push(Token("0",LITERAL,INTEGER));
                    }
                }
            }
            else if(strcmp(curr.value(),">") == 0 || strcmp(curr.value(),">=") == 0 || strcmp(curr.value(),"<") == 0 || strcmp(curr.value(), "<=") == 0) {
                Token a,b;
                operandStack.pop(b);
                operandStack.pop(a);
                if(a.subType() == VARIABLE)
                    a = getVariable(a.value()).value();
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    a = getVariable(e.v).value(e.i);
                }
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                operandStack.push(Compare(a,b,curr.value()));
            }
            else if(strcmp(curr.value(),"and") == 0) {
                Token a,b;
                operandStack.pop(b);
                operandStack.pop(a);
                Token d;
                if(a.subType() == VARIABLE)
                    a = getVariable(a.value()).value();
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    a = getVariable(e.v).value(e.i);
                }
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                operandStack.push(multiply(a,b));
            }
            else if(strcmp(curr.value(),"or") == 0 ) {
                Token a,b;
                operandStack.pop(b);
                operandStack.pop(a);
                if(a.subType() == VARIABLE)
                    a = getVariable(a.value()).value();
                else if(a.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
                    a = getVariable(e.v).value(e.i);
                }
                if(b.subType() == VARIABLE)
                    b = getVariable(b.value()).value();
                else if(b.subType() == ARRAYELEM) {
                    arrayElem e = arrayElems[ getIndexOfHash(b.value()) ];
                    b = getVariable(e.v).value(e.i);
                }
                operandStack.push(add(a,b));
            }
            else if(strcmp(curr.value(),"return") == 0) {
                if(!functionStack.isEmpty()) {
                    Token t;
                    operandStack.pop(t);
                    if(isVariable(t.value())) t = getVariable(t.value()).value();
                    else if(t.subType() == ARRAYELEM) {
                        arrayElem e = arrayElems[ getIndexOfHash(t.value()) ];
                        t = getVariable(e.v).value(e.i);
                    }
                    functionStack.Top().setReturn(t);
                    
                }
            }
            else if(strcmp(curr.value(),"[]") == 0) {
                Token v,i;
                operandStack.pop(i);
                i = evaluateRPN(rpns[getIndexOfHash(i.value())]);
                operandStack.pop(v);
                char n[101];
                if(getVariable(v.value()).isArray()) {
                    arrayElem a;
                    strcpy(a.v, getVariable(v.value()).getID());
                    a.i = atoi(i.value());
                    arrayElems.push_back(a);
                    hashify((int)arrayElems.size() - 1,n);
                    operandStack.push(Token(n,HASHED,ARRAYELEM));
                }
                else {
                    stringChar a;
                    strcpy(a.v, getVariable(v.value()).getID());
                    a.i = atoi(i.value());
                    stringChars.push_back(a);
                    hashify((int)stringChars.size() - 1,n);
                    operandStack.push(Token(n,HASHED,STRINGCHAR));
                    
                }
            }
            else if(strcmp(curr.value(),".") == 0) {
                Token a,b;
                operandStack.pop(b);
                operandStack.pop(a);
                Token op;
                if(strcmp(b.value(),"length") == 0) {
                    if(a.type() == LITERAL) op = a;
                    else if(a.subType() == VARIABLE) {
                        op = getVariable(a.value()).value();
                    }
                    else if(a.subType() == ARRAYELEM) {
                        arrayElem e = arrayElems[getIndexOfHash(a.value())];
                        op = getVariable(e.v).value(e.i);
                    }
                    operandStack.push(convertIntegerToToken((int)strlen(op.value()) - 2));
                    operandStack.Top();
                }
            }
        }
        else if(curr.type() == KEYWORD) {
            if(curr.subType() == IOFUNCTION) {
                if(strcmp(curr.value(), "write") == 0) {
                    Token t;
                    operandStack.pop(t);
                    io_write(evaluateRPN(rpns[ getIndexOfHash( t.value() ) ] ) );
                    
                }
                else if(strcmp(curr.value(),"writeLine") == 0) {
                    Token t;
                    operandStack.pop(t);
                    io_write(evaluateRPN(rpns[ getIndexOfHash( t.value() ) ] ) );
                    cout<<endl;
                    
                }
                else if(strcmp(curr.value(),"readInteger") == 0) {
                    Token t;
                    operandStack.pop(t);
                    io_write(evaluateRPN(rpns[ getIndexOfHash( t.value() ) ] ) );
                    operandStack.push(io_readInteger());
                }
                else if(strcmp(curr.value(),"readNumeric") == 0) {
                    Token t;
                    operandStack.pop(t);
                    io_write(evaluateRPN(rpns[getIndexOfHash(t.value())]));
                    operandStack.push(io_readNumeric());
                }
                else if(strcmp(curr.value(),"readLine") == 0) {
                    Token t;
                    operandStack.pop(t);
                    io_write(evaluateRPN(rpns[getIndexOfHash(t.value())]));
                    operandStack.push(io_readLine());
                }
                else if(strcmp(curr.value(),"read") == 0) {
                    Token t;
                    operandStack.pop(t);
                    io_write(evaluateRPN(rpns[getIndexOfHash(t.value())]));
                    operandStack.push(io_read());
                }
                else if(strcmp(curr.value(),"readTime") == 0) {
                    Token t;
                    operandStack.pop(t);
                    io_write(evaluateRPN(rpns[getIndexOfHash(t.value())]));
                    cout<<endl;
                    operandStack.push(io_readTime());
                }
                else if(strcmp(curr.value(),"readDate") == 0) {
                    Token t;
                    operandStack.pop(t);
                    io_write(evaluateRPN(rpns[getIndexOfHash(t.value())]));
                    cout<<endl;
                    operandStack.push(io_readDate());
                }
            }
            else if(strcmp(curr.value(), "if") == 0) {
                Token c;
                operandStack.pop(c);
                if(evaluateRPN(ifs[getIndexOfHash(c.value())].If_condition).value()[0] != '0')  {
                    variables.push(ifs[getIndexOfHash(c.value())].If_variables);
                    evaluateRPN(ifs[getIndexOfHash(c.value())].If_statement);
                    variables.pop();
                }
                else {
                    variables.push(ifs[getIndexOfHash(c.value())].Else_variables);
                    evaluateRPN(ifs[getIndexOfHash(c.value())].Else_statement);
                    variables.pop();
                }
            }
            else if(strcmp(curr.value(),"while") == 0) {
                Token c;
                operandStack.pop(c);
                int i = 0;
                while(evaluateRPN(ifs[getIndexOfHash(c.value())].If_condition).value()[0] != '0' && !i)  {
                    variables.push(ifs[getIndexOfHash(c.value())].If_variables);
                    evaluateRPN(ifs[getIndexOfHash(c.value())].If_statement);
                    variables.pop();
                    if(!functionStack.isEmpty()) {
                        i = functionStack.Top().hasReturned();
                    }
                }
            }
            else if(strcmp(curr.value(),"for") == 0) {
                Token c;
                operandStack.pop(c);
                variables.push(fors[getIndexOfHash(c.value())].Counter_variables);
                int i = 0;
                evaluateRPN(fors[getIndexOfHash(c.value())].s1);
                while(evaluateRPN(fors[getIndexOfHash(c.value())].s2).value()[0] != '0'   && !i)  {
                    variables.push(fors[getIndexOfHash(c.value())].For_variables);
                    evaluateRPN(fors[getIndexOfHash(c.value())].statements);
                    evaluateRPN(fors[getIndexOfHash(c.value())].s3);
                    variables.pop();
                    if(!functionStack.isEmpty()) {
                        i = functionStack.Top().hasReturned();
                    }
                }
                variables.pop();
            }
        }
        
    }
    Token a;
    operandStack.pop(a);
    if(a.subType() == VARIABLE)
        a = getVariable(a.value()).value();
    else if(a.subType() == ARRAYELEM) {
        arrayElem e = arrayElems[ getIndexOfHash(a.value()) ];
        a = getVariable(e.v).value(e.i);
    }
    else if(a.subType() == STRINGCHAR) {
        stringChar e  = stringChars[ getIndexOfHash(a.value())];
        a = getCharAt(e);
    }
    return a;
}

/********** RPN_EVALUATOR:END **********/

void lineOfStars(int n) {
    for(int i = 0;i < n;i++) cout<<"*";
    cout<<endl;
}

void stars(int n) {
    for(int i = 0;i < n;i++) cout<<"*";
}

void sort(Vector<Error> &e) {
    int i,j;
    Error v;
    for(i = 1;i < e.size();i++) {
        v = e[i];
        for(j = i - 1;j >= 0 && e[j].getLineNumber() > v.getLineNumber();j--) {
            e[j + 1] = e[j];
        }
        e[j + 1] = v;
    }
}

/*
 FUNCTION    : evaluate();
 DESCRIPTION : calls the functions from the 2 components of the intepreter including RPN_CONVERTER and RPN_EVALUATOR.
 RETURNS     : void
 PARAMETERS  : Queue<Token>
 */
void evaluate(Queue<Token> n) {
    lineOfStars(75);
    RPN r = convertToRPN(n,variables.Top());
    checkRPN(r);
    if(interpretationSuccessful) {
        cout<<wall;
        fillRestOfLine(WALL);
        cout<<wall<<tab<<"INTERPRETATION SUCCESSFUL!";
        fillRestOfLine(WALL + TAB - 1 + strlen("INTERPRETATION SUCCESSFUL!"));
        cout<<wall;
        fillRestOfLine(WALL);
        lineOfStars(75);
        cout<<endl<<endl;
        cout<<"********************************* RUNNING *********************************"<<endl<<endl;
        evaluateRPN(r);
        cout<<endl<<endl;
        if(errors.size() > 0) {
            cout<<errors[0].getFlag()<<endl;
        }
        cout<<"******************************** PROGRAM ENDED ****************************"<<endl<<endl;
    }
    if(!interpretationSuccessful) {
        char n[101];
        cout<<wall;
        fillRestOfLine(WALL);
        n[0] = 0;
        strcat(n,convertIntegerToToken(errors.size()).value());
        strcat(n," error(s) detected: ");
        cout<<wall<<tab<<n;
        fillRestOfLine(WALL + TAB + strlen(n) -1);
        sort(errors);
        for(int i = 0;i < errors.size();i++) {
            n[0] = 0;
            strcat(n,"Error: ");
            strcat(n,convertIntegerToToken(i + 1).value());
            strcat(n," - line ");
            strcat(n,convertIntegerToToken(errors[i].getLineNumber()).value());
            strcat(n, " -> ");
            strcat(n,errors[i].getFlag());
            cout<<wall<<tab<<tab<<n;
            fillRestOfLine(WALL + TAB + TAB + strlen(n) - 1);
        }
        cout<<wall;
        fillRestOfLine(WALL);
        cout<<wall<<tab<<"INTERPRETATION FAILED..";
        fillRestOfLine(WALL + TAB - 1 + strlen("INTERPRETATION FAILED.."));
        cout<<wall;
        fillRestOfLine(WALL);
    }
    lineOfStars(75);
}

/*
 FUNCTION    : fileRead();
 DESCRIPTION : the function takes a filename as parameter and reads from file, tokenizes by assiging line numbers too. It calls the evaluate function too.
 RETURNS     : void
 PARAMETERS  : char[]
 */
void fileRead(char f[101]) {
    ifstream fin(f);
    if(!fin) {
        cout<<"FILE READING FAILED."<<endl;
        return;
    }
    int i = 0;
    Queue<Token> tokens,temp;
    char line[101];
    fin.getline(line,101);
    while(fin) {
        temp = tokenize(line);
        Token t;
        while(temp.qdelete(t)) tokens.qinsert(t);
        fin.getline(line,101);
        currentLine++;
    }
    evaluate(tokens);
}

/*
 FUNCTION    : isValidFile();
 DESCRIPTION : takes file name as parameter, checks if it has a .pm extension.
 RETURNS     : int
 PARAMETERS  : char[]
 */
int isValidFile(char n[]) {
	int pd = -1;
	for(int i = 0;n[i] && pd == -1;i++) {
		if(n[i] == '.') pd = i;
	}
	if(pd == -1) return 0;
	else {
		if(n[pd + 1] == 'p' && n[pd + 2] == 'm' && n[pd + 3] ==0) return 1;
	}
	return 0;
}

int main() {
    cout<<"Enter the file: ";
    char n[101];
    cin.getline(n,101);
    variables.push(Vector<Variable>());
	while(!isValidFile(n)) {
		cout<<"Enter a file with extension .pm : ";
		cin.getline(n,101);
	}
    fileRead(n);
}
